
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>minify</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-19"><meta name="DC.source" content="minify.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>minify</h1><!--introduction--><p><tt style="font-size:0%">Formatted documentation for the minify function.</tt>
<div style="margin-top:-5em;color:grey">Process Matlab code into a solid block of compact and unreadable but functionally equivalent code.
</div>
</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Syntax</a></li><li><a href="#3">Output arguments</a></li><li><a href="#4">Input arguments</a></li><li><a href="#5">BeastMode parameters</a></li><li><a href="#6">Example</a></li><li><a href="#7">Compatibility, version info, and licence</a></li><li><a href="#8">Performance</a></li><li><a href="#9">Test suite</a></li></ul></div><h2 id="1">Description</h2><p>
The likely use cases fall generally under two categories:<br>
<ol>
   <li> Attaching code as a dependency to allow your code to run, without having to refer to
      separate FEX/Github entries. In some such places understanding the attached code is not
      important, while space is at a premium (e.g. pdf attachments, where large amounts of
      dependent code would be distracting).</li>
   <li> Code obfuscation. Since p-code will only run on a subset of Matlab releases (and not at
      all on GNU Octave), using that will limit compatibility. Additionally, given that the
      encryption has been broken, this might be a good additional step (or replacement) to hide
      the function of your code without harming its function.</li>
</ol>
The process of compacting Matlab code is split into several steps (steps 3-8 should be performed
for each function separately and some steps are optional):<br><br>
<ol>
   <li> Strip all comments and line continuations.</li>
   <li> Sort the functions (if there are multiple) in order to keep the entry function(s) at the
      top of the output.</li>
   <li> Separate the code and the embedded chars/strings.</li>
   <li> Parse the code to select only the places where a new variable may be created in the
      workspace. False positives should be avoided at all costs. False negatives should be
      avoided, but are not a major issue.</li>
   <li> Use that (and the list of local functions) to create a dictionary of variable and
      function names.</li>
   <li> Remove the entry function from that dictionary and replace every occurrence of a variable
      or local function with a shorter/pseudonymized one.</li>
   <li> Replace all double spaces in code with single space.</li>
   <li> Put the code and chars/strings back together.</li>
   <li> Merge lines if the result is shorter that a fixed length. A space, comma, or semicolon
      may be added. Be careful with functions that rely on printing results to the command
      window by omitting the semicolon, although such functions should probably not be minified
      in the first place (as the variable names are changed).</li>
</ol>
This function was tested on a random sample of m-files from the FileExchange. Some limits were
imposed on the selection of files: only submissions with 5 downloads or more in the last 30
days, at most 5 files per submission (taking the first files in the hierarchy, without checking
if those actually would contain the main function), ignoring functions with fewer than 5 or more
than 1000 lines (and functions with less than 2 lines of actual code), and ignoring functions
with lines over 1000 characters long (as those probably contain data, not real code). If
BeastMode is set to true the size of functions tends to be reduced to about &#8539; of the
original number of lines. Setting BeastMode to false will increase the variability by a lot, and
results in file sizes of about half of the original number of lines.
<br>The compression depends mostly on the amount of comments, typical line length, amount and
length of chars/strings, and typical variable name length. See the performance section below for
more precise figures for typical compression rates.
</p><h2 id="2">Syntax</h2><pre class="language-matlab">str_out=minify(str_in)
str_out=minify(str_in,BeastMode)
str_out=minify(str_in,BeastMode,max_length_after_merge)
str_out=minify(str_in,BeastMode,max_length_after_merge,EntryFunctionNames)
</pre><h2 id="3">Output arguments</h2><p>
<table border=1>
<tr><td>
str_out
</td><td>
mx1 cell array with the minified code
</td></tr>
</table>
</p><h2 id="4">Input arguments</h2><p>
<table border=1>
<tr><td>
str_in
</td><td>
nx1 cell array of char arrays
</td></tr>
<tr><td>
BeastMode
</td><td>
A logical that triggers additional steps to further minify the code. If this input is
<code>true</code> (or <code>1</code>, <code>'on'</code>, ect), all defaults described below are
used. <code>false</code> (or an invalid input) will set all fields to <code>false</code>.
<br>Specific aspects can be set individually by supplying a <code>struct</code> instead. Any
missing field will be filled with the default.
<tr><td>
max_length_after_merge
</td><td>
This is the target maximum length (the line length might be exceeded by the original code after
the removal of the line continuation)
<br>If <code>max_length_after_merge&lt;10</code>, this value is multiplied by the maximum line
length preference.
<br>(if you want more than 10x, you can provide a negative value)
</td></tr>
<tr><td>
EntryFunctionNames
</td><td>
This is a cell array or chars with function names that should be kept unchanged. These functions
will be move to the top if there are multiple functions. This defaults to the first function (if
any).
</td></tr>
<tr><td>
AlwaysSpaceEllipsis
</td><td>
In R2021a the interpretation of an ellipsis changed. Starting from this release
<code>'...\n\s*'</code> is not gobbled, but it is interpreted as a space. See <a
href="http://web.archive.org/web/20210504113526/https://www.mathworks.com/help/matlab/release-notes.html#mw_ef23ce50-083b-4ec9-af8c-e8d65d8ce308">this</a>
section in the release notes.
<br>This parameter must be either a logical or empty. If true, an ellipsis will be interpreted a
space (note that this doesn't mean a space will be added). The default will be determined based
on the behavior of the release calling this function.
</td></tr>
</table>
</p><h2 id="5">BeastMode parameters</h2><p>
<table border=1>
<tr><td>trim_spaces</td><td>
<code>default=1;</code> Strip leading spaces and remove all double spaces that do not occur
inside a char or a string.</td></tr>
<tr><td>compress_to_block</td><td>
<code>default=0;</code> Attempt to compress the entire input to a single block.
<br>Setting this to <code>true</code> will cause the resulting code to be incompatible between
modern Matlab releases and Octave and ML6.5. The reason is that the former require a space
between <code>'end'</code> and <code>'function'</code>, while the latter require a comma or
semicolon.</td></tr>
<tr><td>compress_functions_separately</td><td>
<code>default=1;</code> Compress each function to a separate block of code.
<br>If proper detection of nested function is implemented, this will compress each parent
function including the nested functions to a single block.
<br>If compress_to_block is set to true, this is ignored.</td></tr>
<tr><td>keep_original_function_names</td><td>
<code>default=0;</code> Do not rename local functions.
<br>This setting can be used if any code uses <code>eval</code> with the name of a local function
in a <code>char</code> or a <code>string</code>. (you can use
<code>func2str(@local_function)</code> to work around this issue)</td></tr>
<tr><td>contains_nested_functions</td><td>
<code>default=0;</code> Setting this to true will skip the steps that would break nested
functions.</td></tr>
</table>
</p><h2 id="6">Example</h2><pre class="codeinput"><span class="comment">% You can get the readfile function here: www.mathworks.com/matlabcentral/fileexchange/68780.</span>
<span class="keyword">try</span> tf=isempty(which(func2str(@readfile)));<span class="keyword">catch</span>,tf=true;<span class="keyword">end</span>
<span class="keyword">if</span> tf,readfile=@(fn)split(fileread(fn),{newline,[char(13) newline]});<span class="keyword">end</span>
<span class="comment">% Read a function to a cellstr.</span>
str=readfile([mfilename <span class="string">'.m'</span>]);
<span class="comment">% Minify the function.</span>
str=minify(str);
<span class="comment">% Generate a function name.</span>
[p,n]=fileparts(tempname);fn_out=[p filesep <span class="string">'fun_'</span> n <span class="string">'.m'</span>];
<span class="comment">% Write the minified function to a file.</span>
fid=fopen(fn_out,<span class="string">'w'</span>);fprintf(fid,<span class="string">'%s\n'</span>,str{:});fclose(fid);
<span class="comment">% Open the result in the editor.</span>
edit(fn_out)
</pre><h2 id="7">Compatibility, version info, and licence</h2><p>
Compatibility considerations:
<ul>
   <li> Octave and ML6.5 require a semicolon or comma between <code>'end'</code> and
      <code>'function'</code>, while newer Matlab releases either require a space or newline.
      Setting <code>compress_to_block</code> to true will make the resulting code incompatible
      between the two styles.</li>
   <li> The command syntax (e.g. <code>warning off all</code>) will be incorrectly parsed. The
      literal text part of the call will be treated as normal code (so <code>off=false;warning
      off all</code> will become <code>v000=false;warning v000 all</code>). Consider using the
      function syntax instead.</li>
   <li> Support for <code>eval</code> and friends is limited to situation where they don't rely
      on variable/function names (e.g. if it is used to create an anonymous function). You could
      use something like <code>func2str(@local_function)</code> to use a local function call
      inside an <code>eval</code> statement.</li>
   <li> Nested functions are tricky to extract. It is possible (match up end statements with
      <code>'if'</code>, <code>'try'</code>, <code>'while'</code>, <code>'for'</code>,
      <code>'parfor'</code>, and <code>'function'</code>, then confirm every function has an
      <code>'end'</code> and ignore nested functions while sorting the functions). I don't use
      them (as they are incompatible with Matlab&nbsp;6.5 and Octave), but it isn't impossible to
      modify this function. You can set <code>contains_nested_functions</code> to true to turn
      off the parts that will interfere with nested functions.</li>
   <li> There is no support for the arguments block. This is not a fundamental issue, it is just
      not yet implemented in this function. Feel free to suggest the required edits on GitHub.
      The priority of this issue for me is low.</li>
   <li> If you use <code>load()</code> without an output argument, that will create variables in
      your workspace. This function doesn't know the variable names, so that syntax will result
      in errors. Use the <code>S=load(___);</code> syntax instead.</li>
   <li>Using <code>save(___)</code> might cause issues if the specific variable is renamed. In a
      future version of this function it may be possible to protect the variable names in a
      <code>save</code> call. Currently you should use a function that converts the input
      variable to a char, e.g. <code>var2str=@(x) inputname(1);</code>.</li>
   <li> Be careful with the <code>plot(x,y,LineWidth=2)</code> syntax (introduced in R2021a). If
      you have a variable or local function with the name <code>LineWidth</code>, this result in
      <code>LineWidth</code> being replaced by the shortened name. It might be possible to adapt
      this function to detect such use cases and avoid replacements. Feel free to suggest the
      required edits on GitHub. The priority of this issue for me is low.</li>
   <li> The interpretation of a line continuation <a
      href="http://web.archive.org/web/20210504113526/https://www.mathworks.com/help/matlab/release-notes.html#mw_ef23ce50-083b-4ec9-af8c-e8d65d8ce308">changed</a>
      in R2021a: "Previously, if an ellipsis followed an operator inside of a matrix or cell
      array, it caused the operator to be treated as unary. Ellipses will now be treated as a
      space in all cases."
      <br>This function will return unambiguous code, but the interpretation of the input will be
      controled by the AlwaysSpaceEllipsis parameter. The default behavior follows the default
      from the release used.</li>
</ul>
</p><p>
<table>
<tr>
<td> Test suite result </td>
<td style="border:2px solid black;"> Windows XP/7/10 </td>
<td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
<td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2021a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2020b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2020a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2018a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2015a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2013b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2012b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2011a </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2010b </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2010a </td>
<td> <it>W7 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab R2007b </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab 7.1 (R14SP3) </td>
<td> <it>XP : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Matlab 6.5 (R13) </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 6.2.0 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 5.2.0 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it>Pass</it> </td>
<td> <it></it> </td>
</tr>
<tr>
<td style="border:2px solid black;"> Octave 4.4.1 </td>
<td> <it>W10 : Pass</it> </td>
<td> <it></it> </td>
<td> <it>Pass</it> </td>
</tr>
</table>
</p><pre>Version: 1.0.1
Date:    2020-12-23
Author:  H.J. Wisselink
Licence: CC by-nc-sa 4.0 ( https://creativecommons.org/licenses/by-nc-sa/4.0 )
Email = 'h_j_wisselink*alumnus_utwente_nl';
Real_email = regexprep(Email,{'*','_'},{'@','.'})</pre><h2 id="8">Performance</h2><p>
The benchmarking function used to generate the results below can be found
<a href=https://web.archive.org/web/20210519084221/https://cdn-117.anonfiles.com/l7dcV7w3ua/4d2c7f86-1621414338/aaa___minify___performance_test.m>here</a>.
<br>The test results shown in the tables below are normalized to the results of the newest
Matlab release on Windows, since the performace is strongly dependent on the specific
computer running the test. To allow absolute comparisons as well the results in that cell
are shown in seconds.
<br>
<br>Note that every result apart from those under Windows 10 was obtained in a VM, so the
performance is likely an underestimation of the true performance.
<br>
<br>A random sample of 1000 m-files was downloaded from the FEX around 2021/05/18.<br>With BeastMode, 50% of functions are between 10.0 and 18.0% of original size (median 13%).<br>Without BeastMode, 50% of functions are between 38.4 and 65.1% of original size (median 52%).<br>The timing test below shows results for fewer files and only uses BeastMode.<br>
<br>
<table>
<tr>
<td> Test suite result </td>
<td style="border:2px solid black;"> Windows XP/7/10 </td>
<td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
<td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2021a </td>
<td> (W10) <br> 4.858&nbsp;s </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2020b </td>
<td> (W10) <br> 102&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2020a </td>
<td> (W10) <br> 108&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2018a </td>
<td> (W10) <br> 112&nbsp;% </td>
<td> 108&nbsp;% </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2015a </td>
<td> (W10) <br> 162&nbsp;% </td>
<td> 179&nbsp;% </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2013b </td>
<td> (W10) <br> 153&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2012b </td>
<td> (W10) <br> 153&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2011a </td>
<td> (W10) <br> 148&nbsp;% </td>
<td> 147&nbsp;% </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2010b </td>
<td>  </td>
<td> 189&nbsp;% </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2010a </td>
<td> (W7) <br> 150&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab R2007b </td>
<td> (W10) <br> 143&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab 7.1 (R14SP3) </td>
<td> (XP) <br> 171&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Matlab 6.5 (R13) </td>
<td> (W10) <br> 218&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Octave 6.2.0 </td>
<td> (W10) <br> 540&nbsp;% </td>
<td>  </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Octave 5.2.0 </td>
<td> (W10) <br> 499&nbsp;% </td>
<td> 347&nbsp;% </td>
<td>  </td>
</tr>
<tr>
<td style="border:2px solid black;vertical-align:middle"> Octave 4.4.1 </td>
<td> (W10) <br> 484&nbsp;% </td>
<td>  </td>
<td> 783&nbsp;% </td>
</tr>
</table>
</p><h2 id="9">Test suite</h2><p>This tester is included so you can test if your own modifications would introduce any bugs. These tests form the basis for the compatibility table above.</p><p>Note that some of the functions in this tester might be different from the functions included in the actual function. Usually this is done to allow triggering of certain errors.</p><p>To save space, the tester function below was minified. The full tester function (including all comments) can be found <a href="https://web.archive.org/web/20210519084431/https://cdn-112.anonfiles.com/X9d8Vawcu3/011bdc76-1621414466/aaa___minify___test.m">here</a>.</p><pre class="codeinput"><span class="comment">%  Test the most important stages separately, and check if the output of the whole chain is stable.</span>
<span class="comment">%</span>
<span class="comment">% Pass:    passes all tests</span>
<span class="comment">% Partial: [no partial passing condition]</span>
<span class="comment">% Fail:    fails any test</span>
<span class="comment">%</span>
<span class="keyword">function</span> v000=aaa___minify___test(varargin),v000=<span class="string">'pass'</span>;<span class="keyword">global</span> <span class="keyword">...</span>
HJW___test_suit___debug_hook_data,HJW___test_suit___debug_hook_data=[];v001=<span class="string">'comment stripping'</span>;
[v002,v003]=comment_stripper_test_data;<span class="keyword">try</span> v004=[];v005 = StripComments(v002);v006=false;<span class="keyword">catch</span> <span class="keyword">...</span>
v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> v006 || ~isequal(v005,v003),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
error([<span class="string">'test did not match expected output ('</span> v001 <span class="string">')'</span>]),<span class="keyword">end</span>,<span class="keyword">end</span>,v001=<span class="string">'char/string detection'</span>;
[v002,v003]=char_and_code_split_test_data;<span class="keyword">try</span> v004=[];v007=SplitCodeAndChar(v002);
v003(cellfun(<span class="string">'isempty'</span>,v003))={<span class="string">''</span>};v007( cellfun(<span class="string">'isempty'</span>,v007 ))={<span class="string">''</span>};v006=false;<span class="keyword">catch</span> v004;
<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v006 || ~isequal(v007,v003),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
error([<span class="string">'test did not match expected output ('</span> v001 <span class="string">')'</span>]),<span class="keyword">end</span>,<span class="keyword">end</span>,v001=<span class="keyword">...</span>
<span class="string">'function/variable name detection'</span>;[v002,v008,v009]=generate_fill_workspace;<span class="keyword">try</span> v004=[];v010=<span class="keyword">...</span>
ListVariables(v002);v011=ListLocalFunctions(v002);v006=false;<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=<span class="keyword">...</span>
lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v006 || (~isequal(v010,<span class="keyword">...</span>
v008) || ~isequal(v011,v009) ),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
error([<span class="string">'test did not match expected output ('</span> v001 <span class="string">')'</span>]),<span class="keyword">end</span>,<span class="keyword">end</span>,v002=[generate_fill_workspace;
char_and_code_split_test_data;comment_stripper_test_data];v012=<span class="keyword">...</span>
<span class="string">'omnibus test part %d did not match expected hash\n(expected %s, returned %s)'</span>;v013=1;v004=[];
v014=<span class="string">''</span>;v015=<span class="string">''</span>;<span class="keyword">try</span> v016=minify(v002,true,80,{<span class="string">'fill_workspace'</span>,<span class="string">'fun_loc_1'</span>},<span class="string">' '</span>);v014=<span class="keyword">...</span>
ComputeNonCryptHash(v016,128,<span class="string">'-v2'</span>);v015=<span class="string">'45A0B7E551B62340E286BA5E683EAEF4'</span>;v006=false;<span class="keyword">catch</span> <span class="keyword">...</span>
v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> v006 || ~strcmp(v014,v015),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,v013=2;v004=[];v014=<span class="string">''</span>;v015=<span class="string">''</span>;v017=struct(<span class="string">'compress_to_block'</span>,true);<span class="keyword">try</span> v016=<span class="keyword">...</span>
minify(v002,v017,80,{<span class="string">'fill_workspace'</span>,<span class="string">'fun_loc_1'</span>},<span class="string">' '</span>);v014=ComputeNonCryptHash(v016,128,<span class="keyword">...</span>
<span class="string">'-v2'</span>);v015=<span class="string">'933B7389C25AD11AD94C2C83F046688F'</span>;v006=false;<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=<span class="keyword">...</span>
lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v006 || ~strcmp(v014,<span class="keyword">...</span>
v015),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">end</span>,<span class="keyword">end</span>,v013=3;v004=[];
v014=<span class="string">''</span>;v015=<span class="string">''</span>;v017=true;HJW___test_suit___debug_hook_data=struct(<span class="string">'action'</span>,<span class="string">'return'</span>,<span class="string">'data'</span>,<span class="keyword">...</span>
{{true}});<span class="keyword">try</span> v016=minify(v002,v017,80,[],<span class="string">' '</span>);v014=ComputeNonCryptHash(v016,128,<span class="string">'-v2'</span>);v015=<span class="keyword">...</span>
<span class="string">'1CC9CB35AF3DCB66994638850B108D2D'</span>;v006=false;<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,<span class="keyword">...</span>
disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v006 || ~strcmp(v014,v015),<span class="keyword">if</span> <span class="keyword">...</span>
nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">end</span>,<span class="keyword">end</span>,v013=4;v004=[];v014=<span class="string">''</span>;
v015=<span class="string">''</span>;<span class="keyword">try</span> v016=minify(v002,true,80,{<span class="string">'fill_workspace'</span>},<span class="string">' '</span>);v014=ComputeNonCryptHash(v016,128,<span class="keyword">...</span>
<span class="string">'-v2'</span>);v015=<span class="string">'4E58F69325634C36FD628F32AC5C4298'</span>;v006=false;<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=<span class="keyword">...</span>
lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v006 || ~strcmp(v014,<span class="keyword">...</span>
v015),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">end</span>,<span class="keyword">end</span>,v013=5;v004=[];
v014=<span class="string">''</span>;v015=<span class="string">''</span>;<span class="keyword">try</span> v016=minify(v002,false,80,{<span class="string">'fill_workspace'</span>},<span class="string">' '</span>);v014=<span class="keyword">...</span>
ComputeNonCryptHash(v016,128,<span class="string">'-v2'</span>);v015=<span class="string">'B985E20AFB7B5FB62630EE0561BF254F'</span>;v006=false;<span class="keyword">catch</span> <span class="keyword">...</span>
v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> v006 || ~strcmp(v014,v015),<span class="keyword">if</span> nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,v013=6;v004=[];v014=<span class="string">''</span>;v015=<span class="string">''</span>;v017=struct(<span class="string">'keep_original_function_names'</span>,true);<span class="keyword">try</span> <span class="keyword">...</span>
v016=minify(v002,v017,80,{<span class="string">'fill_workspace'</span>},<span class="string">' '</span>);v014=ComputeNonCryptHash(v016,128,<span class="string">'-v2'</span>);v015=<span class="keyword">...</span>
<span class="string">'1CC9CB35AF3DCB66994638850B108D2D'</span>;v006=false;<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,<span class="keyword">...</span>
disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v006 || ~strcmp(v014,v015),<span class="keyword">if</span> <span class="keyword">...</span>
nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">end</span>,<span class="keyword">end</span>,v013=7;v004=[];v014=<span class="string">''</span>;
v015=<span class="string">''</span>;v017=struct(<span class="string">'contains_nested_functions'</span>,true);<span class="keyword">try</span> v016=minify(v002,v017,80,<span class="keyword">...</span>
{<span class="string">'fill_workspace'</span>},<span class="string">' '</span>);v014=ComputeNonCryptHash(v016,128,<span class="string">'-v2'</span>);v015=<span class="keyword">...</span>
<span class="string">'05DBBE2C6772AFE90068983326831695'</span>;v006=false;<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,<span class="keyword">...</span>
disp(v004.message),disp(v004.identifier),v006=true;<span class="keyword">end</span>,<span class="keyword">if</span> v006 || ~strcmp(v014,v015),<span class="keyword">if</span> <span class="keyword">...</span>
nargout&gt;0,v000=<span class="string">'fail'</span>;<span class="keyword">return</span>,<span class="keyword">else</span>,error(v012,v013,v015,v014),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
disp(<span class="string">'test finished successfully'</span>),<span class="keyword">if</span> nargout==0,clear,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_char(v001,v002),<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> nargin==1,v002=~v003;<span class="keyword">end</span>,<span class="keyword">if</span> v002,<span class="keyword">if</span> <span class="keyword">...</span>
all(v001&lt;65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));<span class="keyword">else</span>,[v004,v005,v006]=<span class="keyword">...</span>
unique(v001);v000=cell(1,numel(v001));<span class="keyword">for</span> v007=1:numel(v004),v008=unicode_to_UTF16(v004(v007));
v008=uint16(v008);v000(v006==v007)={v008};<span class="keyword">end</span>,v000=cell2mat(v000);<span class="keyword">end</span>,<span class="keyword">if</span> ~v003,v000=char(v000);
<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> all(v001&lt;128),v000=char(v001);v000=reshape(v000,1,numel(v000));<span class="keyword">else</span>,[v004,v005,<span class="keyword">...</span>
v006]=unique(v001);v000=cell(1,numel(v001));<span class="keyword">for</span> v007=1:numel(v004),v008=<span class="keyword">...</span>
unicode_to_UTF8(v004(v007));v008=uint8(v008);v000(v006==v007)={v008};<span class="keyword">end</span>,v000=cell2mat(v000);
v000=char(v000);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=SetDefault_end_function_char(v000),<span class="keyword">persistent</span> v001,<span class="keyword">if</span> nargin&gt;0, v001=v000;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v001),<span class="keyword">if</span> ifversion(<span class="string">'&lt;'</span>,7,<span class="string">'Octave'</span>,<span class="string">'&gt;'</span>,0),v001=<span class="string">','</span>;<span class="keyword">else</span>, v001=<span class="string">' '</span>;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> nargout&gt;0,<span class="keyword">...</span>
v000=v001;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=comma_or_semicolon(v001),v000=repmat(<span class="string">','</span>,numel(v001),1);v002=<span class="keyword">...</span>
cumsum(cellfun(<span class="string">'prodofsize'</span>,v001));v001=horzcat(v001{:});v003 = double(v001==<span class="string">'['</span>) - <span class="keyword">...</span>
double(v001==<span class="string">']'</span>);v004 = double(v001==<span class="string">'{'</span>) - double(v001==<span class="string">'}'</span>);v005 = ( <span class="keyword">...</span>
cumsum(v003)+cumsum(v004) );v006=v005(v002)~=0;v000(v006)=<span class="string">';'</span>;v006=ismember(v002,strfind(v001,<span class="keyword">...</span>
<span class="string">'endfunction'</span>)+2);v000(v006)=SetDefault_end_function_char;<span class="keyword">end</span>
<span class="keyword">function</span> v000=parse_warning_error_redirect_options(v000),<span class="keyword">if</span> ~isfield(v000,<span class="string">'boolean'</span>),<span class="keyword">...</span>
v000.boolean=struct;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'con'</span>) || isempty(v000.boolean.con),<span class="keyword">...</span>
v000.boolean.con=false;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'fid'</span>) || isempty(v000.boolean.fid),<span class="keyword">...</span>
v000.boolean.fid=isfield(v000,<span class="string">'fid'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="string">'obj'</span>) || <span class="keyword">...</span>
isempty(v000.boolean.obj),v000.boolean.obj=isfield(v000,<span class="string">'obj'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000.boolean,<span class="keyword">...</span>
<span class="string">'fcn'</span>) || isempty(v000.boolean.fcn),v000.boolean.fcn=isfield(v000,<span class="string">'fcn'</span>);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v002=transposing_scalar_string_is_fixed,<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v001=<span class="string">'""'''</span>;
v000=isequal(StripComments(v001),v001);<span class="keyword">if</span> ~v000,error(<span class="string">'This should have been fixed already.'</span>),<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,v002=v000;<span class="keyword">end</span>
<span class="keyword">function</span> v000=GetMaxLineLengthPref(varargin),<span class="keyword">persistent</span> v001 v002,<span class="keyword">if</span> isempty(v001),<span class="keyword">...</span>
v001.isOctave=exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>);<span class="keyword">if</span> ~v001.isOctave,v001.settings=ifversion(<span class="string">'&gt;='</span>,<span class="keyword">...</span>
<span class="string">'R2018a'</span>);v001.com.mathworks=ifversion(<span class="string">'&gt;='</span>,<span class="string">'R13'</span>);v001.R13=ifversion(<span class="string">'=='</span>,<span class="string">'R13'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.isOctave,v002=80;<span class="keyword">elseif</span> ifversion(<span class="string">'&lt;='</span>,<span class="string">'R2010b'</span>),v002=75;<span class="keyword">else</span>,v002=80;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.isOctave,v000=0;<span class="keyword">elseif</span> v001.settings,v003 = settings;v000=<span class="keyword">...</span>
v003.matlab.editor.displaysettings.linelimit.LineColumn.ActiveValue;<span class="keyword">elseif</span> v001.com.mathworks,<span class="keyword">...</span>
v000=com.mathworks.services.Prefs.getIntegerPref(<span class="string">'EditorRightTextLineLimit'</span>);<span class="keyword">elseif</span> v001.R13,<span class="keyword">...</span>
v000=com.mathworks.services.Prefs.getIntegerPref(<span class="string">'EditorMaxCommentWidth'</span>);<span class="keyword">else</span>,v000=80;<span class="keyword">end</span>,v000=<span class="keyword">...</span>
double(v000);<span class="keyword">if</span> isempty(v000) || v000==0,v000=v002;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ifversion(v001,v002,v003,v004,v005),<span class="keyword">persistent</span> v006 v007 v008,<span class="keyword">if</span> isempty(v006),<span class="keyword">...</span>
v008=exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>);v006=version;v009=strfind(v006,<span class="string">'.'</span>);<span class="keyword">if</span> numel(v009)~=1,<span class="keyword">...</span>
v006(v009(2):end)=<span class="string">''</span>;v009=v009(1);<span class="keyword">end</span>,v006=[str2double(v006(1:(v009-1))) <span class="keyword">...</span>
str2double(v006((v009+1):end))];v006=v006(1)+v006(2)/100;v006=round(100*v006);v007={ <span class="string">'R13'</span> 605;
<span class="string">'R13SP1'</span> 605;<span class="string">'R13SP2'</span> 605;<span class="string">'R14'</span> 700;<span class="string">'R14SP1'</span> 700;<span class="string">'R14SP2'</span> 700;<span class="string">'R14SP3'</span> 701;<span class="string">'R2006a'</span> 702;
<span class="string">'R2006b'</span> 703;<span class="string">'R2007a'</span> 704;<span class="string">'R2007b'</span> 705;<span class="string">'R2008a'</span> 706;<span class="string">'R2008b'</span> 707;<span class="string">'R2009a'</span> 708;<span class="string">'R2009b'</span> 709;
<span class="string">'R2010a'</span> 710;<span class="string">'R2010b'</span> 711;<span class="string">'R2011a'</span> 712;<span class="string">'R2011b'</span> 713;<span class="string">'R2012a'</span> 714;<span class="string">'R2012b'</span> 800;<span class="string">'R2013a'</span> 801;
<span class="string">'R2013b'</span> 802;<span class="string">'R2014a'</span> 803;<span class="string">'R2014b'</span> 804;<span class="string">'R2015a'</span> 805;<span class="string">'R2015b'</span> 806;<span class="string">'R2016a'</span> 900;<span class="string">'R2016b'</span> 901;
<span class="string">'R2017a'</span> 902;<span class="string">'R2017b'</span> 903;<span class="string">'R2018a'</span> 904;<span class="string">'R2018b'</span> 905;<span class="string">'R2019a'</span> 906;<span class="string">'R2019b'</span> 907;<span class="string">'R2020a'</span> 908;
<span class="string">'R2020b'</span> 909;<span class="string">'R2021a'</span> 910};<span class="keyword">end</span>,<span class="keyword">if</span> v008,<span class="keyword">if</span> nargin==2,warning(<span class="string">'HJW:ifversion:NoOctaveTest'</span>,<span class="keyword">...</span>
[<span class="string">'No version test for Octave was provided.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'This function might return an unexpected outcome.'</span>]),<span class="keyword">if</span> isnumeric(v002),v010=<span class="keyword">...</span>
0.1*v002+0.9*fix(v002);v010=round(100*v010);<span class="keyword">else</span>,v011=ismember(v007(:,1),v002);<span class="keyword">if</span> sum(v011)~=1,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NotInDict'</span>,<span class="string">'The requested version is not in the hard-coded list.'</span>),v000=<span class="keyword">...</span>
NaN;<span class="keyword">return</span>,<span class="keyword">else</span>,v010=v007{v011,2};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> nargin==4,[v001,v010]=deal(v003,v004);v010=<span class="keyword">...</span>
0.1*v010+0.9*fix(v010);v010=round(100*v010);<span class="keyword">else</span>,[v001,v010]=deal(v004,v005);v010=<span class="keyword">...</span>
0.1*v010+0.9*fix(v010);v010=round(100*v010);<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> isnumeric(v002),v010=<span class="keyword">...</span>
0.1*v002+0.9*fix(v002);v010=round(100*v010);<span class="keyword">else</span>,v011=ismember(v007(:,1),v002);<span class="keyword">if</span> sum(v011)~=1,<span class="keyword">...</span>
warning(<span class="string">'HJW:ifversion:NotInDict'</span>,<span class="string">'The requested version is not in the hard-coded list.'</span>),v000=<span class="keyword">...</span>
NaN;<span class="keyword">return</span>,<span class="keyword">else</span>,v010=v007{v011,2};<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">switch</span> v001,<span class="keyword">case</span> <span class="string">'=='</span>, v000= v006 == v010;<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'&lt;'</span> , v000= v006 &lt; v010;<span class="keyword">case</span> <span class="string">'&lt;='</span>, v000= v006 &lt;= v010;<span class="keyword">case</span> <span class="string">'&gt;'</span> , v000= v006 &gt; v010;<span class="keyword">case</span> <span class="string">'&gt;='</span>, <span class="keyword">...</span>
v000= v006 &gt;= v010;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ListLocalFunctions(v003),v004=isa(v003,<span class="string">'char'</span>);<span class="keyword">if</span> v004,v003={v003};
<span class="keyword">end</span>,[v005,v003]=SplitCodeAndChar(v003);v006=warning(<span class="string">'off'</span>,<span class="string">'MATLAB:REGEXP:deprecated'</span>);v000=<span class="keyword">...</span>
cell(0);v001=zeros(0);v002=zeros(0);v007=0;<span class="keyword">for</span> v008=1:numel(v003),[v009,v010]=<span class="keyword">...</span>
ExtractCommandsFromLine(v003{v008});<span class="keyword">for</span> v011=1:numel(v009),v012=<span class="keyword">...</span>
ListLocalFunctions_helper(v009{v011});<span class="keyword">if</span> ~isempty(v012),v007=v007+1;v000{v007,1}=v012;v001(v007,<span class="keyword">...</span>
1)=v008;v002(v007,1)=v010(v011);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> numel(v000)==0,v000={<span class="string">'function'</span>};<span class="keyword">end</span>,<span class="keyword">if</span> v004,<span class="keyword">...</span>
v000=v000{1};<span class="keyword">end</span>,warning(v006);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ListVariables(v001),v002=warning(<span class="string">'off'</span>,<span class="string">'MATLAB:REGEXP:deprecated'</span>);<span class="keyword">persistent</span> <span class="keyword">...</span>
v003,<span class="keyword">if</span> isempty(v003),<span class="keyword">try</span> unique([1 1 2],<span class="string">'stable'</span>);v003=false;<span class="keyword">catch</span>,v003=true;<span class="keyword">end</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
cell(0);v004=0;v005={<span class="string">'varargin'</span>;<span class="string">'varargout'</span>};v006=2;<span class="keyword">for</span> v007=1:numel(v001),v008=<span class="keyword">...</span>
ExtractCommandsFromLine(v001{v007});<span class="keyword">for</span> v009=1:numel(v008),[v000,v004,v005,v006]=<span class="keyword">...</span>
ListVariables_ParseLine(v008{v009},v000,v004,v005,v006);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> ~v003,v000=unique(v000,<span class="keyword">...</span>
<span class="string">'stable'</span>);<span class="keyword">else</span>,[v010,v011]=unique(v000);v000=v000(sort(v011));<span class="keyword">end</span>,v000(ismember(v000,v005))=[];
v000(ListVariables_HasHandleRef(v000,v001))=[];warning(v002),<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002,v003]=ListVariables_ParseLine(v004,v000,v001,v002,v003),<span class="keyword">persistent</span> <span class="keyword">...</span>
v005,<span class="keyword">if</span> isempty(v005),v005 = exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,v006=[<span class="string">' '</span> v004];v007=<span class="keyword">...</span>
<span class="string">'\s*function[\s\[](.*)'</span>;v008=regexp(v004,v007,<span class="string">'once'</span>);<span class="keyword">if</span> ~isempty(v008);v006=regexprep(v004,<span class="keyword">...</span>
v007,<span class="string">'$1'</span>, <span class="string">'tokenize'</span>);v009=<span class="string">'(^)|(\]?\s*=)\s*(([a-zA-Z]+[_a-zA-Z0-9]*))[^_a-zA-Z]'</span>;[v010,v011]=<span class="keyword">...</span>
regexp(v006,v009);<span class="keyword">try</span> v012=v006(v010(1):v011(1));v012=regexprep(v012,<span class="keyword">...</span>
<span class="string">'[^_a-zA-Z0-9]*([_a-zA-Z0-9]*)[^_a-zA-Z0-9]*'</span>,<span class="string">'$1'</span>,<span class="string">'tokenize'</span>);<span class="keyword">catch</span>,v012=regexprep(v006,v009,<span class="keyword">...</span>
<span class="string">'$1'</span>,<span class="string">'tokenize'</span>);<span class="keyword">end</span>,v006=regexprep(v006,[<span class="string">'\]?\s*=\s*'</span> v012 <span class="string">'\s*\((.*)\)'</span>],<span class="string">',$1]'</span>, <span class="string">'tokenize'</span>);
v006=strrep(v006,v012,<span class="string">''</span>);<span class="keyword">if</span> isempty(v006),<span class="keyword">return</span>,<span class="keyword">end</span>;[v000,v001]=<span class="keyword">...</span>
ListVariables_ParseOutputVariables(v006,v000,v001);<span class="keyword">return</span>;<span class="keyword">end</span>;v013=zeros(size(v006));v006 =<span class="keyword">...</span>
strrep(v006,<span class="string">'}{'</span>,<span class="string">'__'</span>);v014 =<span class="string">'{'</span>;v013( v006==v014 )= 1;v015=<span class="string">'}'</span>;v013([false v006==v015])=-1;
v013=cumsum(v013);v006(v013(1:(end-1))&gt;0)=<span class="string">''</span>;v013=zeros(size(v006));v014 =<span class="string">'('</span>;v013( v006==v014 <span class="keyword">...</span>
)= 1;v015=<span class="string">')'</span>;v013([false v006==v015])=-1;v013=cumsum(v013);v006(v013(1:(end-1))&gt;0)=<span class="string">''</span>;v016=<span class="keyword">...</span>
{<span class="string">'[;,\s]'</span> , <span class="string">'\s+(([a-zA-Z][a-zA-Z0-9_]*\s*)*)'</span>};v017= [v016{1} <span class="string">'persistent'</span> v016{2}];<span class="keyword">if</span> v005;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(regexp(v006,v017, <span class="string">'once'</span>));<span class="keyword">else</span>;v018=regexprep(v006,v017,<span class="string">'$1'</span>);[v000,v001]=<span class="keyword">...</span>
ListVariables_ParseOutputVariables(v018,v000,v001);v006=regexprep(v006,v017,<span class="string">''</span>);<span class="keyword">end</span>;<span class="keyword">else</span>;[v019,<span class="keyword">...</span>
v020,v018]=regexp(v006,v017);<span class="keyword">for</span> v021=numel(v018):-1:1;[v000,v001]=<span class="keyword">...</span>
ListVariables_ParseOutputVariables(v006(v018{v021}(1):v018{v021}(2)),v000,v001);
v006(v019(v021):v020(v021))=<span class="string">''</span>;<span class="keyword">end</span>;<span class="keyword">end</span>;v017= [v016{1} <span class="string">'global'</span> v016{2}];<span class="keyword">if</span> v005;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(regexp(v006,v017, <span class="string">'once'</span>));<span class="keyword">else</span>;v018=regexprep(v006,v017,<span class="string">'$1'</span>);[v002,v003]=<span class="keyword">...</span>
ListVariables_ParseOutputVariables(v018,v002,v003);v006=regexprep(v006,v017,<span class="string">''</span>);<span class="keyword">end</span>;<span class="keyword">else</span>;[v019,<span class="keyword">...</span>
v020,v018]=regexp(v006,v017);<span class="keyword">for</span> v021=numel(v018):-1:1;[v002,v003]=<span class="keyword">...</span>
ListVariables_ParseOutputVariables(v006(v018{v021}(1):v018{v021}(2)),v002,v003);
v006(v019(v021):v020(v021))=<span class="string">''</span>;<span class="keyword">end</span>;<span class="keyword">end</span>;v006=strrep(v006,<span class="string">'=='</span>,<span class="string">'&lt;'</span>);v006=strrep(v006,<span class="string">'~='</span>,<span class="string">'&lt;'</span>);
v006=strrep(v006,<span class="string">'&gt;='</span>,<span class="string">'&lt;'</span>);v006=strrep(v006,<span class="string">'&lt;='</span>,<span class="string">'&lt;'</span>);<span class="keyword">for</span> v022=numel(v006):-1:1;v008=find(v006==<span class="keyword">...</span>
<span class="string">'='</span>);<span class="keyword">if</span> isempty(v008);<span class="keyword">break</span>;<span class="keyword">else</span>;v006(v008(end):end)=<span class="string">''</span>;v008={max(find(v006==<span class="string">'['</span>)), <span class="keyword">...</span>
max([find(v006==<span class="string">','</span>) find(v006==<span class="string">';'</span>)]), 1};v008=[v008{:}];v008=v008(1);v023=v006(v008(end):end);
v006(v008(end):end)=<span class="string">''</span>;v023=regexprep(v023,<span class="string">'\s+for\s+'</span>,<span class="string">''</span>);v023=regexprep(v023,<span class="string">'\s+try\s+'</span>,<span class="string">''</span>);
[v000,v001]=ListVariables_ParseOutputVariables(v023,v000,v001);<span class="keyword">end</span>;<span class="keyword">end</span>;<span class="keyword">end</span>
<span class="keyword">function</span> v000=ListVariables_HasHandleRef(v001,v002),v002=sprintf(<span class="string">'%s '</span>,v002{:});v003=<span class="keyword">...</span>
<span class="string">'@[a-zA-Z]+[_a-zA-Z0-9]*'</span>;v004=regexp_outkeys(v002,v003,<span class="string">'match'</span>);v004=strrep(v004,<span class="string">'@'</span>,<span class="string">''</span>);v000=<span class="keyword">...</span>
ismember(v001,v004);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ListLocalFunctions_helper(v001),v000=<span class="string">''</span>;v002=<span class="string">'\s*function[\s\[](.*)'</span>;v003=<span class="keyword">...</span>
regexp(v001,v002,<span class="string">'once'</span>);<span class="keyword">if</span> ~isempty(v003);v004=regexprep(v001,v002,<span class="string">'$1'</span>, <span class="string">'tokenize'</span>);v004=<span class="keyword">...</span>
v004( max([1 1+strfind(v004,<span class="string">'='</span>)]) : min([strfind(v004,<span class="string">'('</span>)-1 numel(v004)]) );v000=strrep(v004,<span class="keyword">...</span>
<span class="string">' '</span>,<span class="string">''</span>);<span class="keyword">end</span>;<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=ListVariables_ParseOutputVariables(v002,v000,v001),[v003,v004,v005]=<span class="keyword">...</span>
regexp(v002,<span class="string">'\[(.*)\]|((.*)?)'</span>);v002=v002(v005{1}(1):v005{1}(2));v006 = <span class="keyword">...</span>
<span class="string">'[^a-zA-Z_\.]([a-zA-Z][a-zA-Z0-9_]*)'</span>;v002=[<span class="string">' '</span> v002];[v003,v004,v005]=regexp(v002,v006);<span class="keyword">for</span> <span class="keyword">...</span>
v007=1:numel(v005),v001=v001+1;v000{v001,1}=v002(v005{v007}(1):v005{v007}(2));<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=MergeLineContinuation(v000,v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002=<span class="keyword">...</span>
numel(eval(sprintf(<span class="string">'[1 -...\n2]'</span>)))==1;<span class="keyword">end</span>,v003=v002;<span class="keyword">if</span> nargin==2 &amp;&amp; ~isempty(v001),v003=v001;
<span class="keyword">end</span>,<span class="keyword">for</span> v004 = (numel(v000)-1):-1:1,v005=false;<span class="keyword">if</span> numel(v000{v004})&gt;=3,v005=<span class="keyword">...</span>
strcmp(v000{v004}((end-2):end),<span class="string">'...'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> v005,v000{v004}((1+regexp(v000{v004},<span class="keyword">...</span>
<span class="string">'\s*...$'</span>)):end)=<span class="string">''</span>;<span class="keyword">if</span> v000{v004}(end)==<span class="string">'.'</span>,v000{v004}(end)=<span class="string">''</span>;<span class="keyword">end</span>,v006=<span class="keyword">...</span>
find(~isspace(v000{v004+1}));<span class="keyword">if</span> ~isempty(v006)&amp;&amp;v006(1)&gt;1,v006=v006(1);<span class="keyword">else</span>,v006=1;<span class="keyword">end</span>,<span class="keyword">if</span> v003,<span class="keyword">...</span>
<span class="keyword">if</span> numel(v000{v004})&gt;=1 &amp;&amp; any(v000{v004}(end)== <span class="string">',;*/^\@&lt;&gt;&amp;|='</span>),v007=<span class="string">''</span>;<span class="keyword">else</span>,v007=<span class="string">' '</span>;<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
<span class="keyword">if</span> numel(v000{v004})&gt;=1 &amp;&amp; any(v000{v004}(end)==<span class="string">'+-~,;*/^\@&lt;&gt;&amp;|='</span>),v007=<span class="string">''</span>;<span class="keyword">else</span>,v007=<span class="string">' '</span>;<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">if</span> v006==1,v000{v004}=[v000{v004} v007 v000{v004+1} ];v000(v004+1)=[];<span class="keyword">else</span>,v000{v004}=<span class="keyword">...</span>
[v000{v004} v007 v000{v004+1}(v006:end)];v000(v004+1)=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=MergeShortLines(v000,v001,v002),<span class="keyword">if</span> nargin&lt;3,v002=true;<span class="keyword">end</span>,v000(cellfun(<span class="string">'isempty'</span>,<span class="keyword">...</span>
v000))=[];v003=comma_or_semicolon(v000);<span class="keyword">for</span> v004=(numel(v000)-1):-1:1,v005=v000{v004};v006=<span class="keyword">...</span>
v000{v004+1};<span class="keyword">if</span> strcmp(v005((max(1,end-2)):max(1,end)),<span class="string">'...'</span>),v005((end-2):end)=<span class="string">''</span>;v003(v004)=<span class="keyword">...</span>
<span class="string">' '</span>;<span class="keyword">end</span>,v006=regexprep(v006,<span class="string">'^\s*'</span>,<span class="string">''</span>);<span class="keyword">if</span> v002,<span class="keyword">if</span> strcmp(v006(1:(min(end,8))),<span class="string">'function'</span>),<span class="keyword">...</span>
<span class="keyword">continue</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> ~strcmp(v005(end),<span class="string">';'</span>) &amp;&amp; ~strcmp(v005(end),<span class="string">','</span>),v005=[v005 v003(v004)];<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> strcmp(v005((max(1,end-3)):max(1,end-1)),<span class="string">'try'</span>),v005(end)=<span class="string">' '</span>;<span class="keyword">end</span>,<span class="keyword">if</span> numel(v005)+numel(v006) <span class="keyword">...</span>
&lt;= v001,v000{v004}=[v005 v006];v000(v004+1)=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=generate_fill_workspace,v000={ <span class="keyword">...</span>
<span class="string">'%This file lists most possible syntaxes that result in workspace variables.'</span>;
<span class="string">'%All variables named var__ should be found, but none of the old_var__ variables.'</span>;
<span class="string">'function [var01,var02]=fill_workspace(var03,var04,var05)'</span>;
<span class="string">' function varargout=fun_loc_1(varargin);'</span>;<span class="string">'[var06,var07]=fun_ext_1(old_var1)'</span>;
<span class="string">'var08=fun_ext_2(old_var2);[var09,var10]=fun_ext_3(old_var3);'</span>;<span class="string">'var11.field1=fun_ext_4;'</span>;
<span class="string">'var12.(old_var4)=fun_ext_5;'</span>;<span class="string">'persistent var13;var14=fun_ext_6,persistent var15;'</span>;
<span class="string">';persistent var16 var17'</span>;<span class="string">'global var_glo_01'</span>;<span class="string">'persistent var18;[old_var5];global var_glo_02;'</span>;
<span class="string">'old_var6==old_var7'</span>;<span class="string">'[old_var8 old_var9]'</span>;<span class="string">'if old_var10'</span>;<span class="string">'    1+1;'</span>;<span class="string">'end'</span>;
<span class="string">'  for var19=1:numel(old_var_11),end,if fun_ext_7(old_var11),var20=fun_ext_8(old_var12);end'</span>;
<span class="string">'if fun_ext_9(old_var13)'</span>;<span class="string">'end'</span>;<span class="string">'old_var14,function fun_loc_2'</span>;<span class="string">'function[var21]=fun_loc_3'</span>;
<span class="string">'function var22=fun_loc_4'</span>;<span class="string">'function [var23,var24]=fun_loc_5,fun_ext_10(old_var15)'</span>;
<span class="string">'persistent persistent_var_25'</span>;<span class="string">'persistent var_26_persistent'</span>;<span class="string">'persistent var_persistent_27'</span>;
<span class="string">'persistent_var28=old_var_16;'</span>;
<span class="string">'function [var29,var30]=fun_loc_6,[old_var17(old_var18)];function var31=fun_loc_7'</span>;
<span class="string">'@fun_loc_6'</span>};v001={<span class="string">'var01'</span>;<span class="string">'var02'</span>;<span class="string">'var03'</span>;<span class="string">'var04'</span>;<span class="string">'var05'</span>;<span class="string">'var06'</span>;<span class="string">'var07'</span>;<span class="string">'var08'</span>;<span class="string">'var09'</span>;
<span class="string">'var10'</span>;<span class="string">'var11'</span>;<span class="string">'var12'</span>;<span class="string">'var13'</span>;<span class="string">'var14'</span>;<span class="string">'var15'</span>;<span class="string">'var16'</span>;<span class="string">'var17'</span>;<span class="string">'var18'</span>;<span class="string">'var19'</span>;<span class="string">'var20'</span>;<span class="string">'var21'</span>;
<span class="string">'var22'</span>;<span class="string">'var23'</span>;<span class="string">'var24'</span>;<span class="string">'persistent_var_25'</span>;<span class="string">'var_26_persistent'</span>;<span class="string">'var_persistent_27'</span>;
<span class="string">'persistent_var28'</span>;<span class="string">'var29'</span>;<span class="string">'var30'</span>;<span class="string">'var31'</span>};v002={<span class="string">'fill_workspace'</span>;<span class="string">'fun_loc_1'</span>;<span class="string">'fun_loc_2'</span>;
<span class="string">'fun_loc_3'</span>;<span class="string">'fun_loc_4'</span>;<span class="string">'fun_loc_5'</span>;<span class="string">'fun_loc_6'</span>;<span class="string">'fun_loc_7'</span>};<span class="keyword">end</span>
<span class="keyword">function</span> v000=FillBeastModeStruct(v001),<span class="keyword">persistent</span> v002 v003,<span class="keyword">if</span> isempty(v002),v002=struct;
v002.trim_spaces=true;v002.compress_to_block=false;v002.compress_functions_separately=true;
v002.keep_original_function_names=false;v002.contains_nested_functions=false;v003=v002;v004=<span class="keyword">...</span>
fieldnames(v003);<span class="keyword">for</span> v005=1:numel(v004),v003.(v004{v005})=false;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> ~isa(v001,<span class="string">'struct'</span>),<span class="keyword">...</span>
[v006,v001]=test_if_scalar_logical(v001);<span class="keyword">if</span> ~v006 || v001,v000=v002;<span class="keyword">return</span>,<span class="keyword">else</span>,v000=v003;
<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v000=v002;v004=fieldnames(v001);<span class="keyword">for</span> v005=1:numel(v004),[v006,v007]=<span class="keyword">...</span>
test_if_scalar_logical(v001.(v004{v005}));<span class="keyword">if</span> v006,v000.(v004{v005})=v007;<span class="keyword">else</span>,v000.(v004{v005})=<span class="keyword">...</span>
true;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=SortFunctions(v001,v002),[v003,v004,v005]=ListLocalFunctions(v001);<span class="keyword">if</span> <span class="keyword">...</span>
numel(v004)&lt;=1,v000={v001};<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">if</span> any(v005&gt;1),v006=unique(v004(v005&gt;1)).';v006=<span class="keyword">...</span>
v006(end:-1:1);<span class="keyword">for</span> v007=v006,v008=v001{v007};v009=v005(v004==v007).';v009(v009==0)=[];v010=<span class="keyword">...</span>
diff([0 v009 numel(v008)]);v008=mat2cell(v008,1,v010).';v001=[v001(1:(v007-1));v008;
v001((v007+1):end)];<span class="keyword">end</span>,[v003,v004]=ListLocalFunctions(v001);<span class="keyword">end</span>,[v011,v012]=ismember(v003,<span class="keyword">...</span>
v002);[v013,v014]=sort(v003(~v011));v012(~v011)=sum(v011)+v014;[v013,v012]=sort(v012);v000=<span class="keyword">...</span>
cell(numel(v004),1);v004=[v004;numel(v001)+1];<span class="keyword">for</span> v015=1:numel(v000),v000{v015}=<span class="keyword">...</span>
v001(v004(v015):(v004(v015+1)-1));<span class="keyword">end</span>,v000=v000(v012);<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=char_and_code_split_test_data,v000={<span class="string">'data=[bit1'';bit2'';bit3'';bit4''];'</span>;
<span class="string">'data=[bit1'';''foo%'';bit2'';bit3'';bit4''];'</span>;<span class="string">'data=[bit1'';"foo%";bit2'';bit3'';bit4''];'</span>;
<span class="string">'data=[bit1'';''foo'';''bar'';bit2.'';bit3'';bit4''];'</span>;
<span class="string">'''foo'';''bar'';bit2.'';bit3'';[bit4''];'</span>;<span class="string">' ''foo'';''bar'';bit2.'';bit3'';[bit4''];'</span>;
<span class="string">'data=[bit1'';"foo%".'';bit2'';bit3'';bit4''];'</span>;<span class="string">'data=[bit1'';"foo%"'';bit2'';bit3'';bit4''];'</span>};
v001={<span class="string">'data=[bit1'';bit2'';bit3'';bit4''];'</span>,[],[],[],[];<span class="string">'data=[bit1'';'</span>,<span class="string">'''foo%'''</span>,<span class="keyword">...</span>
<span class="string">';bit2'';bit3'';bit4''];'</span>,[],[];<span class="string">'data=[bit1'';'</span>,<span class="string">'"foo%"'</span>,<span class="string">';bit2'';bit3'';bit4''];'</span>,[],[];
<span class="string">'data=[bit1'';'</span>,<span class="string">'''foo'''</span>,<span class="string">';'</span>,<span class="string">'''bar'''</span>,<span class="string">';bit2.'';bit3'';bit4''];'</span>;[],<span class="string">'''foo'''</span>,<span class="string">';'</span>,<span class="string">'''bar'''</span>,<span class="keyword">...</span>
<span class="string">';bit2.'';bit3'';[bit4''];'</span>;<span class="string">' '</span>,<span class="string">'''foo'''</span>,<span class="string">';'</span>,<span class="string">'''bar'''</span>,<span class="string">';bit2.'';bit3'';[bit4''];'</span>;
<span class="string">'data=[bit1'';'</span>,<span class="string">'"foo%"'</span>,<span class="string">'.'';bit2'';bit3'';bit4''];'</span>,[],[];<span class="string">'data=[bit1'';'</span>,<span class="string">'"foo%"'</span>,<span class="keyword">...</span>
<span class="string">''';bit2'';bit3'';bit4''];'</span>,[],[]};<span class="keyword">if</span> ~transposing_scalar_string_is_fixed,v000(8)=[];v001(8,:)=<span class="keyword">...</span>
[];<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=minify(v000,v001,v002,v003,v004,v005),<span class="keyword">persistent</span> v006,<span class="keyword">if</span> isempty(v006),v006 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;1,error(<span class="string">'not enough inputs'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
nargin&lt;2 || isempty(v001),v001=true;<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;3 || isempty(v002),v002=1.5;<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;5,<span class="keyword">...</span>
v004=[];<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;6,v005=<span class="string">''</span>;<span class="keyword">end</span>,v007=false;<span class="keyword">try</span> v007=isequal(v000,cellstr(v000));<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> ~v007,error(<span class="string">'first input must be a cellstr'</span>);<span class="keyword">end</span>,v001=FillBeastModeStruct(v001);<span class="keyword">if</span> v002&lt;10,<span class="keyword">...</span>
v002=ceil(abs(v002)*GetMaxLineLengthPref);<span class="keyword">end</span>,SetDefault_end_function_char(v005);v000=<span class="keyword">...</span>
StripComments(v000);v000=MergeLineContinuation(v000,v004);<span class="keyword">if</span> numel(v000)==0,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
nargin&lt;4 || isempty(v003),v003=ListLocalFunctions(v000{1});<span class="keyword">end</span>,<span class="keyword">if</span> debug_hook(false),v003=<span class="keyword">...</span>
ListLocalFunctions(v000);<span class="keyword">end</span>,v003=cellstr(v003);<span class="keyword">if</span> ~v001.contains_nested_functions,v008=<span class="keyword">...</span>
SortFunctions(v000,v003);<span class="keyword">else</span>,v008={v000};<span class="keyword">end</span>,<span class="keyword">if</span> v001.keep_original_function_names,v009=cell(0,<span class="keyword">...</span>
2);<span class="keyword">else</span>,[v010,v011]=SplitCodeAndChar(vertcat(v008{:}));v009=ListLocalFunctions(v011);
v009(ismember(v009,v003))=[];<span class="keyword">for</span> v012=1:numel(v009),v009{v012,2}=sprintf(<span class="string">'f%02d'</span>,v012-1);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.contains_nested_functions,v013=ListVariables(v011);<span class="keyword">for</span> v012=1:numel(v013),v013{v012,2}=<span class="keyword">...</span>
sprintf(<span class="string">'v%03d'</span>,v012-1);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">persistent</span> v014,<span class="keyword">if</span> isempty(v014),v014=ifversion(<span class="string">'&gt;='</span>,7,<span class="keyword">...</span>
<span class="string">'Octave'</span>,<span class="string">'&gt;'</span>,0);<span class="keyword">end</span>,<span class="keyword">for</span> v015=1:numel(v008),v000=v008{v015};[v016,v011]=SplitCodeAndChar(v000);
v017=ListVariables(v011);<span class="keyword">if</span> v001.contains_nested_functions,v018=ismember(v013(:,1),v017);v019=<span class="keyword">...</span>
[v009;v013(v018,:)];<span class="keyword">else</span>,<span class="keyword">for</span> v012=1:numel(v017),v017{v012,2}=sprintf(<span class="string">'v%03d'</span>,v012-1);<span class="keyword">end</span>,v019=<span class="keyword">...</span>
[v009;v017];<span class="keyword">end</span>,<span class="keyword">if</span> numel(v019)==0,v019=cell(0);<span class="keyword">end</span>,v020=size(v016,1)==1;<span class="keyword">if</span> v020,v016(2,1)={<span class="string">' '</span>};
<span class="keyword">end</span>,v021=~cellfun(<span class="string">'isempty'</span>,v016);v021(:,2:2:end)=false;<span class="keyword">if</span> v014,<span class="keyword">for</span> v022=1:size(v019,1),v023=<span class="keyword">...</span>
[<span class="string">'(^|(?&lt;=[^a-zA-Z0-9_\.]))('</span> v019{v022,1} <span class="string">')(?=[^a-zA-Z0-9_]|$)'</span>];<span class="keyword">for</span> v024=find(v021).',<span class="keyword">...</span>
v016{v024}=regexprep(v016{v024},v023,v019{v022,2});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">for</span> v022=1:size(v019,1),v023=<span class="keyword">...</span>
[<span class="string">'([^a-zA-Z0-9_\.])('</span> v019{v022,1} <span class="string">')([^a-zA-Z0-9_])'</span>];<span class="keyword">for</span> v024=find(v021).',v000=[<span class="string">' '</span> <span class="keyword">...</span>
v016{v024} <span class="string">' '</span>];v000=regexprep(v000,v023,[<span class="string">'$1'</span> v019{v022,2} <span class="string">'$3'</span>],<span class="string">'tokenize'</span>);v000=<span class="keyword">...</span>
regexprep(v000,v023,[<span class="string">'$1'</span> v019{v022,2} <span class="string">'$3'</span>],<span class="string">'tokenize'</span>);v016{v024}=v000(2:(end-1));<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> v001.trim_spaces,<span class="keyword">for</span> v024=find(v021).',v025=inf;<span class="keyword">while</span> v025~=0,v026=length(v016{v024});
v016{v024}=strrep(v016{v024},<span class="string">'  '</span>,<span class="string">' '</span>);v027=length(v016{v024});v025=v026-v027;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v028=<span class="keyword">...</span>
1:size(v021,1),<span class="keyword">if</span> numel(v016{v028,1})&gt;=1 &amp;&amp; strcmp(v016{v028,1}(1),<span class="string">' '</span>),v016{v028,1}(1)=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v020,v016(2,:)=[];<span class="keyword">end</span>,<span class="keyword">for</span> v028=1:size(v016,1),v029=v016(v028,:);<span class="keyword">if</span> v006,<span class="keyword">...</span>
v029(cellfun(<span class="string">'isempty'</span>,v029))={<span class="string">''</span>};<span class="keyword">end</span>,v016{v028,1}=[v029{:}];<span class="keyword">end</span>,v000=v016(:,1);v008{v015}=<span class="keyword">...</span>
v000;<span class="keyword">end</span>,<span class="keyword">if</span> v001.compress_to_block,<span class="keyword">if</span> numel(v003)&gt;1,v030=cell(1,1+numel(v003));
v030(1:numel(v003))=v008(1:numel(v003));<span class="keyword">if</span> numel(v008)&gt;numel(v003),v031=<span class="keyword">...</span>
v008((numel(v003)+1):end);v030{end}=vertcat(v031{:});<span class="keyword">else</span>,v030(end)=[];<span class="keyword">end</span>,<span class="keyword">for</span> v012=<span class="keyword">...</span>
1:numel(v030),v030{v012}=CompressFunctionBody(v030{v012},v002);<span class="keyword">end</span>,v000=vertcat(v030{:});<span class="keyword">else</span>,<span class="keyword">...</span>
v000=vertcat(v008{:});v000=CompressFunctionBody(v000,v002);<span class="keyword">end</span>,<span class="keyword">elseif</span> <span class="keyword">...</span>
v001.compress_functions_separately,<span class="keyword">for</span> v012=1:numel(v008),<span class="keyword">if</span> numel(v008{v012})==1,<span class="keyword">continue</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v008{v012}=CompressFunctionBody(v008{v012},v002);<span class="keyword">end</span>,v000=vertcat(v008{:});<span class="keyword">else</span>,v000=<span class="keyword">...</span>
vertcat(v008{:});<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=AddMissing(v001,v000),v002=fieldnames(v001);v003=fieldnames(v000);<span class="keyword">for</span> v004=<span class="keyword">...</span>
find(~ismember(v002,v003)).',v005=v002{v004};v000.(v005)=v001.(v005);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=bsxfun_plus(v001,v002),<span class="keyword">try</span> v000=v001+v002;<span class="keyword">catch</span>,<span class="keyword">try</span> v000=bsxfun(@plus,v001,v002);
<span class="keyword">catch</span>,v003=size(v001); v004=size(v002);v001=repmat(v001,max(1,v004./v003)); v002=repmat(v002,<span class="keyword">...</span>
max(1,v003./v004));v000=v001+v002;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector(v000,v001),<span class="keyword">if</span> isa(v000,<span class="string">'uint16'</span>),v002=<span class="string">'uint16'</span>;v003=<span class="keyword">...</span>
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];<span class="keyword">return</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,v000=cast_to_uint16_vector__cell({v000},v001);v000([end-1 end])=[];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__integer(v000,v001),v002=size(v000).';v000=v000(:);
<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003=ifversion(<span class="string">'&gt;='</span>,<span class="string">'R2010b'</span>,<span class="string">'Octave'</span>,<span class="string">'&gt;'</span>,0);<span class="keyword">end</span>,v004=<span class="keyword">...</span>
class(v000);v005=~v001.cast_int64_double &amp;&amp; v003 &amp;&amp; v004(end)==<span class="string">'4'</span>;<span class="keyword">if</span> ~v005,<span class="keyword">if</span> <span class="keyword">...</span>
any(abs(double(v000(:)))&gt;2^52),warning_(v001,<span class="string">'HJW:ComputeNonCryptHash:int64rounding'</span>,<span class="keyword">...</span>
[<span class="string">'int64 and uint64 will be rounded pre-R2010b, resulting in rounding.'</span>,char(10),<span class="keyword">...</span>
<span class="string">'This will result in a hash that is different from newer releases.'</span>]),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v005,<span class="keyword">if</span> <span class="keyword">...</span>
v004(1)~=<span class="string">'u'</span>,v006=v000&gt;0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=<span class="keyword">...</span>
uint64(v000(v006))+uint64(v007)+1;v000=v008;<span class="keyword">end</span>,<span class="keyword">elseif</span> v004(1)~=<span class="string">'u'</span>,v000=<span class="keyword">...</span>
double(v000)-double(eval([v004 <span class="string">'(-inf)'</span>]));<span class="keyword">else</span>,v000=double(v000);<span class="keyword">end</span>,<span class="keyword">switch</span> v004(end),<span class="keyword">case</span> <span class="string">'8'</span>,<span class="keyword">...</span>
<span class="keyword">if</span> mod(numel(v000),2),v000(end+1)=0;<span class="keyword">end</span>,v000=reshape(v000,[],2);v000=v000(:,1)*255+v000(:,2);
v000=uint16(v000);<span class="keyword">case</span> <span class="string">'6'</span>,v000=uint16(v000);<span class="keyword">case</span> <span class="string">'2'</span>,v009=floor(v000/2^16);v009=v009.';v010=<span class="keyword">...</span>
mod(v000,2^16); v010=v010.';v000=[v009;v010];v000=uint16(v000(:));<span class="keyword">case</span> <span class="string">'4'</span>,v011=v000;v012=<span class="keyword">...</span>
mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';v013=mod(v011,2^16);v011=v011-v013;
v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=v011-v010;v011=v011/2^16;v010=v010.';v009=<span class="keyword">...</span>
mod(v011,2^16); v009=v009.';v000=[v009;v010;v013;v012];v000=uint16(v000(:));<span class="keyword">end</span>,v000=[v000;
uint16(v004.');uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__char(v000,v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> v002 &amp;&amp; v001.re_encode_char,v003 = size(v000,1)==<span class="keyword">...</span>
numel(v000);<span class="keyword">if</span> v003,v000=v000.';<span class="keyword">end</span>,v000=cellstr(v000);<span class="keyword">for</span> v004=1:numel(v000),v000{v004}=<span class="keyword">...</span>
unicode_to_char(UTF8_to_unicode(v000{v004},v001.print_to),true);<span class="keyword">end</span>,v005=cellfun(<span class="string">'length'</span>,v000);
v006=max(v005);<span class="keyword">for</span> v004=find(v005&lt;v006),v000{v004}( (numel(v000{v004})+1) : v006)=uint16(<span class="string">' '</span>);
<span class="keyword">end</span>,v000=cell2mat(v000);<span class="keyword">if</span> v003,v000=v000.';<span class="keyword">end</span>,<span class="keyword">end</span>,v007=size(v000).';v000=v000(:);v000=<span class="keyword">...</span>
uint16(v000);v000=[v000;uint16(mod(v007,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__string(v000,v001),<span class="keyword">if</span> v001.string_to_cellstr,v000=<span class="keyword">...</span>
cellstr(v000);v000=cast_to_uint16_vector__cell(v000,v001);<span class="keyword">else</span>,v000=char(v000);v000=<span class="keyword">...</span>
cast_to_uint16_vector__char(v000,v001);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=comment_stripper_test_data,v000=<span class="keyword">...</span>
{<span class="string">'%just a few examples of hard to parse syntaxes'</span>;<span class="string">'''%".''''...''%foo'</span>;<span class="string">'%{'</span>;<span class="string">'bar'</span>;<span class="string">'%}'</span>;<span class="string">'"foo"'</span>;
<span class="string">'bar.'''''</span>;<span class="string">'[foo...'</span>;<span class="string">'    bar]'</span>;<span class="string">'[foo...foobar'</span>;<span class="string">'    bar]'</span>;<span class="string">'""""''%''...'</span>;<span class="string">'foo'</span>;<span class="string">'[""]''.''%foo'</span>;
<span class="string">'[1 2'</span>;<span class="string">'    3 4]'</span>;<span class="string">'%{foo}'</span>;<span class="string">'bar'</span>;<span class="string">'   %foo'</span>};v001={ <span class="string">'''%".''''...'''</span>;<span class="string">'"foo"'</span>;<span class="string">'bar.'''''</span>;
<span class="string">'[foo...'</span>;<span class="string">'    bar]'</span>;<span class="string">'[foo...'</span>;<span class="string">'    bar]'</span>;<span class="string">'""""'''</span>;<span class="string">'foo'</span>;<span class="string">'[""]''.'''</span>;<span class="string">'[1 2'</span>;<span class="string">'    3 4]'</span>;<span class="string">'bar'</span>};
<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__cell(v000,v001),v002=size(v000).';v000=v000(:);<span class="keyword">for</span> v003=<span class="keyword">...</span>
1:numel(v000),<span class="keyword">if</span> numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);<span class="keyword">continue</span>,<span class="keyword">end</span>,<span class="keyword">switch</span> class(v000{v003}),<span class="keyword">case</span> {<span class="string">'double'</span>,<span class="string">'single'</span>},v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__floats(v000{v003});<span class="keyword">case</span> <span class="string">'logical'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__logical(v000{v003});<span class="keyword">case</span> {<span class="string">'uint8'</span>,<span class="string">'uint16'</span>,<span class="string">'uint32'</span>,<span class="string">'uint64'</span>,<span class="string">'int8'</span>,<span class="keyword">...</span>
<span class="string">'int16'</span>,<span class="string">'int32'</span>,<span class="string">'int64'</span>},v000{v003}=cast_to_uint16_vector__integer(v000{v003},v001);<span class="keyword">case</span> <span class="string">'char'</span>,<span class="keyword">...</span>
v000{v003}=cast_to_uint16_vector__char(v000{v003},v001);<span class="keyword">case</span> <span class="string">'string'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__string(v000{v003},v001);<span class="keyword">case</span> <span class="string">'cell'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__cell(v000{v003},v001);<span class="keyword">case</span> <span class="string">'struct'</span>,v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__struct(v000{v003},v001);<span class="keyword">case</span> {<span class="string">'gpuArray'</span>,<span class="string">'tall'</span>},v000{v003}=<span class="keyword">...</span>
cast_to_uint16_vector__cell({gather(v000{v003})},v001);<span class="keyword">otherwise</span>,error_(v001.print_to,<span class="keyword">...</span>
<span class="string">'HJW:cast_to_uint16_vector:nosupport'</span>,<span class="string">'Unsupported data type in nested variable'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
cell2mat(v000);v000=[v000;uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__logical(v000),v001=size(v000).';v000=v000(:);<span class="keyword">if</span> <span class="keyword">...</span>
mod(numel(v000),16),v000(16*ceil(numel(v000)/16))=0;<span class="keyword">end</span>,v002=uint16(2.^(15:-1:0))';v000=<span class="keyword">...</span>
uint16(reshape(v000,16,[]));<span class="keyword">try</span> v000=v000.*v002;<span class="keyword">catch</span>,v000=double(v000).*repmat(double(v002),[1 <span class="keyword">...</span>
size(v000,2)]);v000=uint16(v000);<span class="keyword">end</span>,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,<span class="keyword">...</span>
2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__floats(v000),v001=size(v000).';v002=class(v000);[v003,<span class="keyword">...</span>
v004]=typecast_double_uint64(double(v000));v005=mod(v003,2^16);v003=v003-v005;v003=v003/2^16;
v004=v004.';v006 =mod(v003,2^16);v003=v003-v006; v003=v003/2^16;v006=v006.';v007 =mod(v003,<span class="keyword">...</span>
2^16);v003=v003-v007; v003=v003/2^16;v007=v007.';v008 =mod(v003,2^16); v008=v008.';v000=[v008;
v007;v006;v004];v000=uint16(v000(:));v000=[v000;uint16(v002.');uint16(mod(v001,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> v000=PatternReplace(v001,v002,v003),v000=v001(:)';<span class="keyword">if</span> numel(v002)==0,v004=<span class="keyword">...</span>
false(size(v001));<span class="keyword">elseif</span> numel(v003)&gt;numel(v002),error(<span class="string">'not implemented (padding required)'</span>),<span class="keyword">...</span>
<span class="keyword">else</span>,v004=true(size(v001));<span class="keyword">for</span> v005=1:numel(v002),v006=find(v001==v002(v005));v006=v006-v005+1;
v006(v006&lt;1)=[];v007=false(size(v004));v007(v006)=true;v004= v004 &amp; v007;<span class="keyword">if</span> ~any(v004),<span class="keyword">break</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v006=find(v004);<span class="keyword">if</span> ~isempty(v006),<span class="keyword">for</span> v005=1:numel(v003),v000(v006+v005-1)=<span class="keyword">...</span>
v003(v005);<span class="keyword">end</span>,<span class="keyword">if</span> numel(v003)==0,v005=0;<span class="keyword">end</span>,<span class="keyword">if</span> numel(v002)&gt;v005,v006=v006(:);v008=<span class="keyword">...</span>
(v005+1):numel(v002);v009=bsxfun_plus(v006,v008-1);v000(v009(:))=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=cast_to_uint16_vector__struct(v000,v001),v002=size(v000).';v000=v000(:);v003=<span class="keyword">...</span>
fieldnames(v000);v004=cell(2,numel(v003));<span class="keyword">for</span> v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,<span class="keyword">...</span>
v005}={v000.(v003{v005})};<span class="keyword">end</span>,v000=cast_to_uint16_vector__cell(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];<span class="keyword">end</span>
<span class="keyword">function</span> varargout=regexp_outkeys(v000,v001,varargin),<span class="keyword">if</span> nargin&lt;3,<span class="keyword">...</span>
error(<span class="string">'HJW:regexp_outkeys:SyntaxError'</span>,<span class="string">'No supported syntax used: at least 3 inputs expected.'</span>),<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">if</span> ~(ischar(v000) &amp;&amp; ischar(v001)),error(<span class="string">'HJW:regexp_outkeys:InputError'</span>,<span class="keyword">...</span>
<span class="string">'All inputs must be char vectors.'</span>),<span class="keyword">end</span>,<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002.match = <span class="keyword">...</span>
ifversion(<span class="string">'&lt;'</span>,<span class="string">'R14'</span>,<span class="string">'Octave'</span>,<span class="string">'&lt;'</span>,4);v002.split = ifversion(<span class="string">'&lt;'</span>,<span class="string">'R2007b'</span>,<span class="string">'Octave'</span>,<span class="string">'&lt;'</span>,4);<span class="keyword">end</span>,<span class="keyword">...</span>
varargout=cell(size(varargin));<span class="keyword">for</span> v003=1:(nargin-2),<span class="keyword">if</span> ~ischar(varargin{v003}),<span class="keyword">...</span>
error(<span class="string">'HJW:regexp_outkeys:InputError'</span>,<span class="string">'All inputs must be char vectors.'</span>),<span class="keyword">end</span>,<span class="keyword">switch</span> <span class="keyword">...</span>
lower(varargin{v003}),<span class="keyword">case</span> <span class="string">'match'</span>,<span class="keyword">if</span> v002.match,[v004,v005]=regexp(v000,v001);v006=cell(1,<span class="keyword">...</span>
numel(v004));<span class="keyword">for</span> v007=1:numel(v004),v006{v007}=v000(v004(v007):v005(v007));<span class="keyword">end</span>,<span class="keyword">else</span>,v006=<span class="keyword">...</span>
regexp(v000,v001,<span class="string">'match'</span>);<span class="keyword">end</span>,varargout{v003}=v006;<span class="keyword">case</span> <span class="string">'split'</span>,<span class="keyword">if</span> v002.split,[v004,v005]=<span class="keyword">...</span>
regexp(v000,v001);v008=cell(1,numel(v004)+1);v009=[v004 numel(v000)+1];v010=[0 v005];<span class="keyword">for</span> v007=<span class="keyword">...</span>
1:numel(v009),v008{v007}=v000((v010(v007)+1):(v009(v007)-1));<span class="keyword">end</span>,<span class="keyword">else</span>,v008= regexp(v000,v001,<span class="keyword">...</span>
<span class="string">'split'</span>);<span class="keyword">end</span>,varargout{v003}=v008;<span class="keyword">otherwise</span>,v011=fieldnames(v002);v012=<span class="keyword">...</span>
[<span class="string">'Extra regexp output type not implemented,'</span>,char(10),<span class="string">'only the following'</span>,<span class="keyword">...</span>
<span class="string">' types are implemented:'</span>,char(10),sprintf(<span class="string">'%s, '</span>,v011{:})];v012((end-1):end)=<span class="string">''</span>;
error(<span class="string">'HJW:regexp_outkeys:NotImplemented'</span>,v012),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=char2cellstr(v001,v002),v003=isa(v001,<span class="string">'char'</span>);v001=int32(v001);<span class="keyword">if</span> nargin&lt;2,<span class="keyword">if</span> <span class="keyword">...</span>
any(v001==13),v001=PatternReplace(v001,int32([13 10]),int32(-10));v001(v001==13)=-10;<span class="keyword">end</span>,<span class="keyword">...</span>
v001(v001==10)=-10;<span class="keyword">else</span>,<span class="keyword">for</span> v004=1:numel(v002),v001=PatternReplace(v001,int32(v002{v004}),<span class="keyword">...</span>
int32(-10));<span class="keyword">end</span>,<span class="keyword">end</span>,v005=[0 find(v001==-10) numel(v001)+1];v000=cell(numel(v005)-1,1);<span class="keyword">for</span> v004=<span class="keyword">...</span>
1:numel(v000),v006=(v005(v004 )+1);v007=(v005(v004+1)-1);v000{v004}=v001(v006:v007);<span class="keyword">end</span>,<span class="keyword">if</span> v003,<span class="keyword">...</span>
<span class="keyword">for</span> v004=1:numel(v000),v000{v004}= char(v000{v004});<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">for</span> v004=1:numel(v000),v000{v004}=<span class="keyword">...</span>
uint32(v000{v004});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=SplitCodeAndChar(v002),<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003 = <span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,v000=cell(numel(v002),1);v001=cell(numel(v002),1);
<span class="keyword">for</span> v004=1:numel(v002),v005=SplitLineToCodeAndChar(v002{v004});v000(v004,1:2:(2*size(v005,2)))=<span class="keyword">...</span>
v005(1,:);v000(v004,2:2:(2*size(v005,2)-1))=v005(2,1:(end-1));<span class="keyword">for</span> v006=1:(size(v005,2)-1),v007=<span class="keyword">...</span>
v005{2,v006}(1);v005{2,v006}=[v007 repmat(<span class="string">'_'</span>,1,numel(v005{2,v006})-2) v007];<span class="keyword">end</span>,<span class="keyword">if</span> v003,<span class="keyword">...</span>
v005(cellfun(<span class="string">'isempty'</span>,v005))={<span class="string">''</span>};<span class="keyword">end</span>,v005=[v005{:}];v001{v004}=v005;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=clean_double_equals(v000,v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002=<span class="keyword">...</span>
find(ismember(v001(:,1),<span class="string">'='</span>));<span class="keyword">end</span>,v003= v000==v002 ;v003= v003(1:(end-1)) &amp; v003(2:end) ;
v000(v003)=0;<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=SplitLines(v003),v003=char(v003);v002=false;<span class="keyword">if</span> ~( any(v003==10) || <span class="keyword">...</span>
any(v003==13) ),<span class="keyword">if</span> ispc,v001=char([13 10]);<span class="keyword">else</span>,v001=char(10);<span class="keyword">end</span>,v000={v003};<span class="keyword">else</span>,v004=<span class="keyword">...</span>
find(v003==10 | v003==13);v004=v004(1:min(2,end));<span class="keyword">if</span> numel(v004)==2 &amp;&amp; ( diff(v004)~=1 || <span class="keyword">...</span>
v003(v004(1))==v003(v004(2)) ),v004(2)=[];<span class="keyword">end</span>,v001=v003(v004);<span class="keyword">if</span> numel(v003)&gt;1,v002=strcmp(v001,<span class="keyword">...</span>
v003((end-numel(v001)+1):end));<span class="keyword">end</span>,v000=regexp_outkeys(v003,v001,<span class="string">'split'</span>);v000=v000(:);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=getSplitIndex(v002,v003,v004,v005),v000=[];v001=[];<span class="keyword">if</span> ~any(v002),<span class="keyword">return</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">persistent</span> v006,<span class="keyword">if</span> isempty(v006),v006=cell2mat(v005(:,2)).'/100;<span class="keyword">end</span>,v000=find(v002);<span class="keyword">if</span> v003,<span class="keyword">...</span>
v007=max(50,v004*v006(v002(v000)));[v008,v009]=max(v000-v007);<span class="keyword">else</span>,[v008,v009]=min(v000);<span class="keyword">end</span>,<span class="keyword">...</span>
v000=v000(v009);v001=v002(v000);<span class="keyword">if</span> v003,v010=v005{v001,4}+3*v005{v001,3};<span class="keyword">if</span> v000&gt;(v004+v010),<span class="keyword">...</span>
v002=v002(1:(v000-1));[v000,v001]=getSplitIndex(v002,v003,v004,v005,v006);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash(v001,varargin),<span class="keyword">if</span> nargin&lt;1,<span class="keyword">...</span>
error(<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>,<span class="string">'At least 1 input required.'</span>),<span class="keyword">end</span>,<span class="keyword">if</span> nargin==2 <span class="keyword">...</span>
&amp;&amp; isa(varargin{1},<span class="string">'struct'</span>) &amp;&amp; varargin{1}.SkipInputParse,v002=varargin{1};<span class="keyword">else</span>,[v003,v002,<span class="keyword">...</span>
v004]=ComputeNonCryptHash_parse_inputs(varargin{:});<span class="keyword">if</span> ~v003,rethrow(v004),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v002.print_to=v002.print_2__options;v005=v002.HashLength;v006=v002.Version;<span class="keyword">try</span> v004=[];v001=<span class="keyword">...</span>
cast_to_uint16_vector(v001,v002);<span class="keyword">catch</span> v004;<span class="keyword">if</span> isempty(v004),v004=lasterror;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v004.identifier,<span class="string">'MATLAB:nomem'</span>),error_(v002.print_to,v004),<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v002,<span class="string">'debug'</span>) <span class="keyword">...</span>
&amp;&amp; v002.debug,v007=sprintf(<span class="string">'\n[original error: %s %s]'</span>,v004.identifier,v004.message);<span class="keyword">else</span>,v007=<span class="keyword">...</span>
<span class="string">''</span>;<span class="keyword">end</span>,error_(v002.print_to,<span class="string">'HJW:ComputeNonCryptHash:UnwindFailed'</span>,<span class="keyword">...</span>
[<span class="string">'The nested input contains an unsupported data type.'</span> v007]),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> mod(numel(v001),<span class="keyword">...</span>
v005/16),v008=uint16(1:v005/16).'; v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v006==1,v001=ComputeNonCryptHash_shuffle_uint16(v001);v001=<span class="keyword">...</span>
ComputeNonCryptHash_uint16_to_logical(v001);v001=xor(v001,reshape(v001,[],16).');<span class="keyword">else</span>,v001=<span class="keyword">...</span>
ComputeNonCryptHash_shuffle_uint16(v001);v001=ComputeNonCryptHash_uint16_to_logical(v001);v001=<span class="keyword">...</span>
circshift_by_col(v001);<span class="keyword">end</span>,v001=mod(sum(reshape(v001,v005,[]),2),2);v001=<span class="keyword">...</span>
ComputeNonCryptHash_logical_to_uint16(v001);<span class="keyword">if</span> v002.isSaltCall,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v001=<span class="keyword">...</span>
ComputeNonCryptHash_add_salt(v001,v002);v000=ComputeNonCryptHash_dec2hex(v001);v000=<span class="keyword">...</span>
reshape(v000.',1,[]);<span class="keyword">end</span>
<span class="keyword">function</span> v000=circshift_by_col(v000),<span class="keyword">persistent</span> v001,v002=size(v000);<span class="keyword">if</span> isempty(v001) || <span class="keyword">...</span>
any(size(v001)&lt;v002) || isempty(v001{v002(1),v002(2)}),[v003,v004]=meshgrid(1:size(v000,2),<span class="keyword">...</span>
1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=sub2ind(size(v000),v005,v003);<span class="keyword">if</span> <span class="keyword">...</span>
prod(v002)&lt;=1000,v001{v002(1),v002(2)}=v006;<span class="keyword">end</span>,<span class="keyword">else</span>,v006=v001{v002(1),v002(2)};<span class="keyword">end</span>,v000=<span class="keyword">...</span>
v000(v006);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_add_salt(v000,v001),v002=16*numel(v000);v003=v001;
v003.Version=1; v003.HashLength=v002;v003.SkipInputParse=1; v003.isSaltCall=1;v004=<span class="keyword">...</span>
ComputeNonCryptHash(v000,v003);v004=ComputeNonCryptHash_shuffle_uint16_inv(v004);<span class="keyword">if</span> <span class="keyword">...</span>
v001.Version&gt;1,v004=v004(end:-1:1);<span class="keyword">end</span>,v000=mod(double(v000).*double(v004),1+2^16);v000=<span class="keyword">...</span>
uint16(v000);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_dec2hex(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002=<span class="keyword">...</span>
upper(dec2hex(0:(-1+2^16),4));<span class="keyword">end</span>,v001=double(v001)+1;v000=v002(v001,:);<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_logical_to_uint16(v000),<span class="keyword">if</span> mod(numel(v000),16),<span class="keyword">...</span>
v000(16*ceil(numel(v000)/16))=0;<span class="keyword">end</span>,v001=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
<span class="keyword">try</span> v000=v000.*v001;<span class="keyword">catch</span>,v000=double(v000).*repmat(double(v001),[1 size(v000,2)]);v000=<span class="keyword">...</span>
uint16(v000);<span class="keyword">end</span>,v000=uint16(sum(v000,1)).';<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_shuffle_uint16(v000),v001=65537;v002=479001600;v000 = <span class="keyword">...</span>
uint16(mod(double(v000) * v002 , v001));<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_shuffle_uint16_inv(v000),v001=65537;v002=1919;v000=<span class="keyword">...</span>
uint16(mod(double(v000) * v002,v001));<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002,v003]=parse_warning_error_redirect_inputs(varargin),<span class="keyword">if</span> nargin==1,<span class="keyword">if</span> <span class="keyword">...</span>
isa(varargin{1},<span class="string">'struct'</span>) || isa(varargin{1},<span class="string">'MException'</span>),v004=varargin{1};<span class="keyword">try</span> v002=v004.stack;
v003=get_trace(0,v002);<span class="keyword">catch</span>,[v003,v002]=get_trace(3);<span class="keyword">end</span>,v000=v004.identifier;v001=<span class="keyword">...</span>
v004.message;v005=<span class="keyword">...</span>
<span class="string">'Error using &lt;a href="matlab:matlab.internal.language.introspective.errorDocCallback('</span>;<span class="keyword">if</span> <span class="keyword">...</span>
isa(v004,<span class="string">'struct'</span>) &amp;&amp; numel(v001)&gt;numel(v005) &amp;&amp; strcmp(v005,v001(1:numel(v005))),<span class="keyword">...</span>
v001(1:find(v001==10,1))=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">else</span>,[v003,v002]=get_trace(3);[v000,v001]=deal(<span class="string">''</span>,varargin{1});
<span class="keyword">end</span>,<span class="keyword">else</span>,[v003,v002]=get_trace(3);<span class="keyword">if</span> ~isempty(strfind(varargin{1},<span class="string">'%'</span>)),v000=<span class="string">''</span>;v006=<span class="keyword">...</span>
varargin(2:end);v001=sprintf(varargin{1},v006{:});<span class="keyword">else</span>,v000=varargin{1};v001=varargin{2};<span class="keyword">if</span> <span class="keyword">...</span>
nargin&gt;3,v006=varargin(3:end);v001=sprintf(v001,v006{:});<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=SplitLineToCodeAndChar(v001),v001=[<span class="string">' '</span> v001 <span class="string">' '</span>];v002=DetermineParseState(v001);
v003=diff(v002==0);v004=[1 find(v003==1)+1 ];v005=[ find(v003==-1) numel(v002)];v000=cell(2,<span class="keyword">...</span>
numel(v004));<span class="keyword">for</span> v006=1:numel(v004),v007=v004(v006);v008=v005(v006);v000{1,v006}=<span class="keyword">...</span>
v001(v007:v008);v007=v005(v006)+1;v008=v004(min(v006+1,end))-1;v000{2,v006}=v001(v007:v008);<span class="keyword">end</span>,<span class="keyword">...</span>
v000{1, 1 }( 1 )=<span class="string">''</span>;v000{1,end}(end)=<span class="string">''</span>;<span class="keyword">end</span>
<span class="keyword">function</span> v000=CompressFunctionBody(v001,v002),<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003={ <span class="string">';'</span>, 0,<span class="keyword">...</span>
false,false, 0;<span class="string">','</span>, 0,true ,false, 0;<span class="string">' '</span>, 5,true ,false, 0;<span class="string">'@'</span>,10,true ,false,-1;<span class="string">'='</span>,10,true ,<span class="keyword">...</span>
false, 0};<span class="keyword">end</span>,v002=v002-4;v004=MergeShortLines(v001,inf,false);v004=v004{1};v005=<span class="keyword">...</span>
SplitLineToCodeAndChar(v004);v006=cell(size(v005));<span class="keyword">for</span> v007=1:size(v006,2),v008=<span class="keyword">...</span>
zeros(size(v005{1,v007}));<span class="keyword">for</span> v009=1:size(v003,1),v008(v005{1,v007}==v003{v009,1})=v009;<span class="keyword">end</span>,<span class="keyword">...</span>
v006{1,v007}=v008;v006{2,v007}=zeros(size(v005{2,v007}));<span class="keyword">end</span>,v006=horzcat(v006{:});v006=<span class="keyword">...</span>
clean_double_equals(v006,v003);v000=cell(ceil(numel(v006)/v002),1);v010=0;v011=v004;v012=NaN;
<span class="keyword">while</span> ~isempty(v011),v010=v010+1;<span class="keyword">if</span> numel(v011)==v012,warning(<span class="string">'infinite loop found'</span>),keyboard,<span class="keyword">...</span>
warning(<span class="string">'infinite loop found'</span>),keyboard,<span class="keyword">end</span>,<span class="keyword">if</span> numel(v011)&lt;=v002 || ~any(v006),v000{v010}=v011;
<span class="keyword">break</span>,<span class="keyword">end</span>,[v013,v014]=getSplitIndex(v006(1:v002),true,v002,v003);<span class="keyword">if</span> isempty(v013),[v013,v014]=<span class="keyword">...</span>
getSplitIndex(v006,false,v002,v003);<span class="keyword">end</span>,v013=v013+v003{v014,5};v000{v010}=v011(1:v013);v015=<span class="keyword">...</span>
false;<span class="keyword">if</span> v003{v014,4},v015=true;v016= <span class="string">' '</span> ;<span class="keyword">else</span>,v016=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> v003{v014,3},v015=true;v017=<span class="keyword">...</span>
<span class="string">'...'</span>;<span class="keyword">else</span>,v017=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> v015,v000{v010}=[v000{v010} v016 v017];<span class="keyword">end</span>,v012=numel(v011);
v011(1:v013)=<span class="string">''</span>;v006(1:v013)=[];<span class="keyword">end</span>,v000((v010+1):end)=[];<span class="keyword">end</span>
<span class="keyword">function</span> v000 = StripComments(v001),v002=isa(v001,<span class="string">'string'</span>);<span class="keyword">if</span> v002,v001=cellstr(v001);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
isa(v001,<span class="string">'cell'</span>),<span class="keyword">for</span> v003=1:numel(v001),<span class="keyword">if</span> (ndims(v001{v003}) &gt; 2) || (any(size(v001{v003}) &gt; <span class="keyword">...</span>
0) &amp;&amp; (size(v001{v003}, 1) ~= 1)),error(<span class="string">'HJW:StripComments:InvalidInput'</span>,<span class="keyword">...</span>
<span class="string">'All character arrays must be row vectors.'</span>);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=ischar(v001);<span class="keyword">if</span> v004,[v001,v005,<span class="keyword">...</span>
v006]=SplitLines(v001);<span class="keyword">else</span>,v005=<span class="string">''</span>;v006=false;<span class="keyword">for</span> v003=1:numel(v001),[v001{v003},v007,v008]=<span class="keyword">...</span>
SplitLines(v001{v003});v006=v006 || v008;<span class="keyword">if</span> numel(v001{v003})&gt;1,v005=v007;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v005),v005=v007;<span class="keyword">end</span>,v001=vertcat(v001{:});<span class="keyword">end</span>,v009=cell(1,2);v010=warning(<span class="string">'off'</span>,<span class="keyword">...</span>
<span class="string">'REGEXP:multibyteCharacters'</span>);<span class="keyword">for</span> v003=1:2,<span class="keyword">if</span> v003==1,v011=<span class="string">'\{'</span>;<span class="keyword">else</span>,v011=<span class="string">'\}'</span>;<span class="keyword">end</span>,v009{v003}=<span class="keyword">...</span>
regexp(v001,[<span class="string">'^[^\S]*%'</span> v011 <span class="string">'[^\S]*$'</span>]);<span class="keyword">if</span> isa(v009{v003},<span class="string">'double'</span>),v009{v003}=v009(v003);<span class="keyword">end</span>,<span class="keyword">...</span>
v009{v003}=~cellfun(<span class="string">'isempty'</span>,v009{v003});<span class="keyword">end</span>,warning(v010);v009=cumsum(v009{1}-v009{2})&gt;0 | <span class="keyword">...</span>
v009{2};v001(v009)=[];v000 = v001;<span class="keyword">for</span> v003 = 1:numel(v000),v012 = v000{v003};v012 = <span class="keyword">...</span>
StripComments__line(v012);v013=isspace(v012);<span class="keyword">if</span> all(v013),v014=0;<span class="keyword">else</span>,v014=find(~v013);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isempty(v014)&amp;&amp;v014(end)&lt;numel(v012),v012((v014(end)+1):end)=[];<span class="keyword">end</span>,v000{v003} = v012;<span class="keyword">end</span>,<span class="keyword">...</span>
v000(cellfun(<span class="string">'isempty'</span>,v000))=[];<span class="keyword">if</span> v004,v000 = sprintf([<span class="string">'%s'</span> v005],v000{:});<span class="keyword">if</span> ~v006,<span class="keyword">try</span> <span class="keyword">...</span>
v000((end-numel(v005)+1):end) = <span class="string">''</span>;<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> v002,v000=string(v000);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=StripComments__line(v001),[v002,v003]=SplitLines(v001);<span class="keyword">if</span> numel(v002)&gt;1,<span class="keyword">for</span> v004=<span class="keyword">...</span>
1:numel(v002),v002{v004}=StripComments__line(v002{v004});<span class="keyword">end</span>,v002=v002.';v002(2,1:(end-1))=<span class="keyword">...</span>
{v003};v002{end}=<span class="string">''</span>;v000=horzcat(v002{:});<span class="keyword">if</span> isa(v001,<span class="string">'string'</span>),v000=string(v000);<span class="keyword">end</span>,<span class="keyword">return</span>,<span class="keyword">...</span>
<span class="keyword">else</span>,v001=v002{1};<span class="keyword">end</span>,v005=DetermineParseState(v001);v006=strfind(v001,<span class="string">'%'</span>);v007=strfind(v001,<span class="keyword">...</span>
<span class="string">'...'</span>);v008=[v006(v005(v006)==0) 3+v007(v005(v007)==0)];<span class="keyword">if</span> ~isempty(v008),v001(min(v008):end)=<span class="keyword">...</span>
<span class="string">''</span>;<span class="keyword">end</span>,v000=v001;<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_uint16_to_logical(v000),<span class="keyword">persistent</span> v001,<span class="keyword">if</span> isempty(v001),v001=<span class="keyword">...</span>
dec2bin(0:(-1+2^16))==<span class="string">'1'</span>;v001=v001.';<span class="keyword">end</span>,v000=double(v000)+1;v000=v001(:,v000);<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=test_if_scalar_logical(v001),<span class="keyword">persistent</span> v002,<span class="keyword">if</span> isempty(v002),v002={true,<span class="keyword">...</span>
false;1,0;<span class="string">'on'</span>,<span class="string">'off'</span>;<span class="string">'enable'</span>,<span class="string">'disable'</span>;<span class="string">'enabled'</span>,<span class="string">'disabled'</span>};<span class="keyword">try</span> v002(end+1,:)=<span class="keyword">...</span>
eval(<span class="string">'{"on","off"}'</span>);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v000=true;<span class="keyword">try</span> <span class="keyword">if</span> isa(v001,<span class="string">'char'</span>) || isa(v001,<span class="string">'string'</span>),<span class="keyword">try</span> <span class="keyword">...</span>
v001=lower(v001);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v003=1:size(v002,1),<span class="keyword">for</span> v004=1:2,<span class="keyword">if</span> isequal(v001,v002{v003,<span class="keyword">...</span>
v004}),v001=v002{1,v004};<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> isa(v001,<span class="string">'matlab.lang.OnOffSwitchState'</span>),v001=<span class="keyword">...</span>
logical(v001);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">catch</span>,<span class="keyword">end</span>,v000=false;<span class="keyword">end</span>
<span class="keyword">function</span> v000=ComputeNonCryptHash_DefaultsByVersion(v000),<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'re_encode_char_on_Octave'</span>),v000.re_encode_char=v000.Version&gt;=2;<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'string_to_cellstr'</span>),v000.string_to_cellstr=v000.Version&gt;=2;<span class="keyword">if</span> ~isfield(v000,<span class="keyword">...</span>
<span class="string">'cast_int64_double'</span>),v000.cast_int64_double=v000.Version==1;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs(varargin),v000=true;v002=struct;
<span class="keyword">persistent</span> v003,<span class="keyword">if</span> isempty(v003),v003=struct;v003.HashLength=256;v003.Version=2;
v003.VersionFlag=<span class="string">'-v2'</span>;v003.SkipInputParse=false;v003.isSaltCall=false;v004=struct;
v003.print_to_con=true;v004.print_to_con=v003.print_to_con;v003.print_to_fid=[];
v004.print_to_fid=v003.print_to_fid;v003.print_to_obj=[];v004.print_to_obj=v003.print_to_obj;
v003.print_to_fcn=[];v004.print_to_fcn=v003.print_to_fcn;v003.print_2__default_options=v004;
v003.print_2__options=validate_print_to__options(v004);<span class="keyword">end</span>,<span class="keyword">if</span> nargin==0,v001=<span class="keyword">...</span>
ComputeNonCryptHash_DefaultsByVersion(v003);<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">if</span> nargin==1,<span class="keyword">switch</span> class(varargin{1}),<span class="keyword">...</span>
<span class="keyword">case</span> {<span class="string">'char'</span>,<span class="string">'string'</span>},v001=AddMissing(v003,struct(<span class="string">'VersionFlag'</span>,char(varargin{1})));<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'struct'</span>,v001=AddMissing(v003,varargin{1});<span class="keyword">otherwise</span>,v001=AddMissing(v003,struct(<span class="string">'HashLength'</span>,<span class="keyword">...</span>
varargin{1}));<span class="keyword">end</span>,[v001,v002,v000]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);<span class="keyword">if</span> <span class="keyword">...</span>
v000,v001=ComputeNonCryptHash_DefaultsByVersion(v001);<span class="keyword">end</span>,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">try</span> [v001,v002,v005]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__UnwindToStruct( struct,v002,~v000,varargin{:});v000=~v005;
<span class="keyword">catch</span>,v002.identifier=<span class="string">'HJW:ComputeNonCryptHash:InputFail'</span>;v002.message=<span class="keyword">...</span>
<span class="string">'Input parsing failed. Maybe a parameter has been entered twice.'</span>;v000=false;<span class="keyword">end</span>,<span class="keyword">if</span> ~v000,<span class="keyword">...</span>
<span class="keyword">return</span>,<span class="keyword">else</span> ,v001=AddMissing(v003,v001);<span class="keyword">end</span>,[v001,v002,v000]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);<span class="keyword">if</span> v000,v001=<span class="keyword">...</span>
ComputeNonCryptHash_DefaultsByVersion(v001);<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v000),v002=true;v001=<span class="keyword">...</span>
struct;<span class="keyword">try</span> v003=str2double(v000.VersionFlag(3:end));<span class="keyword">if</span> isnan(v003) || round(v003)~=v003 || <span class="keyword">...</span>
v003&gt;2,error(<span class="string">'trigger'</span>);<span class="keyword">end</span>,v000.Version=v003;<span class="keyword">catch</span>,v001.identifier=<span class="keyword">...</span>
<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>;v001.message=<span class="keyword">...</span>
<span class="string">'Version input incorrect. Must be ''-v1'', ''-v2''.'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,v004=v000.HashLength;
<span class="keyword">if</span> numel(v004)~=1 || ~isnumeric(v004) || mod(v004,16)~=0 || v004&lt;16,v001.identifier=<span class="keyword">...</span>
<span class="string">'HJW:ComputeNonCryptHash:InputIncorrect'</span>;v001.message=<span class="keyword">...</span>
<span class="string">'Second input (hash length) must be a multiple of 16.'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v005=<span class="keyword">...</span>
fieldnames(v000.print_2__default_options),<span class="keyword">if</span> ~isequal(v000.(v005{1}),<span class="keyword">...</span>
v000.print_2__default_options.(v005{1})),[v006,v001]=validate_print_to__options(v000);<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v006),v001.identifier=<span class="string">'HJW:ComputeNonCryptHash:PrintToIncorrect'</span>;v002=false;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v000.print_2__options=v006;<span class="keyword">break</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> varargout=debug_hook(varargin),<span class="keyword">global</span> HJW___test_suit___debug_hook_data,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(HJW___test_suit___debug_hook_data),varargout=varargin;<span class="keyword">return</span>,<span class="keyword">end</span>,v000=<span class="keyword">...</span>
HJW___test_suit___debug_hook_data(1);HJW___test_suit___debug_hook_data(1)=[];<span class="keyword">switch</span> v000.action,<span class="keyword">...</span>
<span class="keyword">case</span> <span class="string">'return'</span>,varargout=v000.data;<span class="keyword">case</span> <span class="string">'warning'</span>,varargout=varargin;warning(v000.data{:}),<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'error'</span>,error(v000.data{:}),<span class="keyword">case</span> <span class="string">'warning_'</span>,varargout=varargin;warning_(v000.data{:}),<span class="keyword">case</span> <span class="keyword">...</span>
<span class="string">'error_'</span>,error_(v000.data{:}),<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,<span class="keyword">...</span>
varargin),<span class="keyword">if</span> v002 || numel(varargin)==0,<span class="keyword">return</span>,<span class="keyword">end</span>,v003=varargin{1};<span class="keyword">if</span> isa(v003,<span class="string">'struct'</span>),v004=<span class="keyword">...</span>
fieldnames(v000);v005=fieldnames(v003);v006=unique([v004;v005]);<span class="keyword">if</span> numel(v004)+numel(v005) ~= <span class="keyword">...</span>
numel(v006),v002=true;<span class="keyword">return</span>,<span class="keyword">end</span>,v000=AddMissing(v000,v003);varargin(1)=[];<span class="keyword">elseif</span> isa(v003,<span class="keyword">...</span>
<span class="string">'char'</span>) || isa(v003,<span class="string">'string'</span>),<span class="keyword">try</span> <span class="keyword">if</span> isa(v003,<span class="string">'string'</span>),v003=char(v003);<span class="keyword">end</span>,<span class="keyword">if</span> strcmpi(<span class="string">'-v'</span>,<span class="keyword">...</span>
v003(1:2)),<span class="keyword">if</span> isfield(v000,<span class="string">'VersionFlag'</span>),error(<span class="string">'trigger'</span>),<span class="keyword">end</span>,v000.VersionFlag=v003;
varargin(1)=[];<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v000,v003),error(<span class="string">'trigger'</span>),<span class="keyword">end</span>,v000.(v003)=varargin{2};
varargin(1:2)=[];<span class="keyword">end</span>,<span class="keyword">catch</span>,v002=true;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> isfield(v000,<span class="string">'HashLength'</span>),v002=true;
<span class="keyword">return</span>,<span class="keyword">end</span>,v000.HashLength=v003;varargin(1)=[];<span class="keyword">end</span>,[v000,v001,v002]=<span class="keyword">...</span>
ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,varargin{:});<span class="keyword">end</span>
<span class="keyword">function</span> v000=DetermineParseState(v001),v001=[<span class="string">' '</span> v001 <span class="string">' '</span>];v002=strfind(v001,<span class="string">''''</span>);v003=<span class="keyword">...</span>
strfind(v001,<span class="string">'"'</span>);v000=zeros(size(v001));<span class="keyword">for</span> v004=sort([v002 v003]),<span class="keyword">if</span> v000(v004)==-1,<span class="keyword">continue</span>,<span class="keyword">...</span>
<span class="keyword">end</span>,<span class="keyword">if</span> strcmp(v001(v004),<span class="string">''''</span>),<span class="keyword">if</span> v000(v004)==5,<span class="keyword">continue</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v000(v004)==2,<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v001(v004+1),<span class="string">''''</span>),v000(v004+1)=-1;<span class="keyword">else</span>,v000(v004)=3;v000((v004+1):end)=0;<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v000(v004-1)~=3 &amp;&amp; ~isempty(regexp(v001(v004-1),<span class="string">'[\]\)}.\w''"]'</span>));<span class="keyword">else</span>;v000(v004)=1;
v000((v004+1):end)=2;<span class="keyword">end</span>;<span class="keyword">end</span>;<span class="keyword">else</span>;<span class="keyword">if</span> v000(v004)==2,<span class="keyword">continue</span>,<span class="keyword">end</span>;<span class="keyword">if</span> v000(v004)==5;<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v001(v004+1),<span class="string">'"'</span>);v000(v004+1)=-1;<span class="keyword">else</span>;v000(v004)=6;v000((v004+1):end)=0;<span class="keyword">end</span>;<span class="keyword">else</span>;
v000(v004)=4;v000((v004+1):end)=5;<span class="keyword">end</span>;<span class="keyword">end</span>;<span class="keyword">end</span>;v000([1 end])=[];<span class="keyword">end</span>
<span class="keyword">function</span> error_(v001,varargin),<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v000=func2str(@error_);<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v001),v001=struct;<span class="keyword">end</span>,v001=parse_warning_error_redirect_options(v001);[v002,v003,v004,<span class="keyword">...</span>
v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct(<span class="string">'identifier'</span>,v002,<span class="string">'message'</span>,<span class="keyword">...</span>
v003,<span class="string">'stack'</span>,v004);<span class="keyword">if</span> v001.boolean.obj,v007=v003;<span class="keyword">while</span> v007(end)==10,v007(end)=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
any(v007==10),v007=char2cellstr([<span class="string">'Error: '</span> v007]);<span class="keyword">else</span>,v007=[<span class="string">'Error: '</span> v007];<span class="keyword">end</span>,<span class="keyword">for</span> v008=<span class="keyword">...</span>
v001.obj(:).',<span class="keyword">try</span> set(v008,<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid,<span class="keyword">for</span> v009=<span class="keyword">...</span>
v001.fid(:).',<span class="keyword">try</span> fprintf(v009,<span class="string">'Error: %s\n%s'</span>,v003,v005);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fcn,<span class="keyword">...</span>
<span class="keyword">if</span> ismember(v000,{v004.name}),error(<span class="string">'prevent recursion'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v010=v001.fcn(:).',<span class="keyword">if</span> <span class="keyword">...</span>
isfield(v010,<span class="string">'data'</span>),<span class="keyword">try</span> feval(v010.h,<span class="string">'error'</span>,v006,v010.data);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">try</span> feval(v010.h,<span class="keyword">...</span>
<span class="string">'error'</span>,v006);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,rethrow(v006),<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=typecast_double_uint64(v002),[v003,v004]=log2(v002);v005 =<span class="keyword">...</span>
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=<span class="keyword">...</span>
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=<span class="keyword">...</span>
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008 &amp; v002&gt;0)=<span class="keyword">...</span>
9218868437227405312;v000(v008 &amp; v002&lt;0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=<span class="keyword">...</span>
0;v001(v008)=0;<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_UTF16(v001),<span class="keyword">if</span> v001&lt;65536,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,v002=double(v001)-65536;
v002=dec2bin(v002,20);v000=bin2dec([<span class="string">'110110'</span> v002(1:10);<span class="string">'110111'</span> v002(11:20)]).';<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=UTF8_to_unicode_internal(v000,v003),v001=<span class="string">'success'</span>;v002=<span class="keyword">...</span>
struct(<span class="string">'identifier'</span>,<span class="string">'HJW:UTF8_to_unicode:notUTF8'</span>,<span class="string">'message'</span>,<span class="string">'Input is not UTF-8.'</span>);<span class="keyword">persistent</span> <span class="keyword">...</span>
v004,<span class="keyword">if</span> isempty(v004),v004 = exist(<span class="string">'OCTAVE_VERSION'</span>, <span class="string">'builtin'</span>) ~= 0;<span class="keyword">end</span>,<span class="keyword">if</span> any(v000&gt;255),v001=<span class="keyword">...</span>
<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">elseif</span> all(v000&lt;128),<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">for</span> v005=4:-1:2,v006=<span class="keyword">...</span>
bin2dec([repmat(<span class="string">'1'</span>,1,v005) repmat(<span class="string">'0'</span>,1,8-v005)]);v007=v000&gt;=v006 &amp; v000&lt;256;<span class="keyword">if</span> any(v007),v007=<span class="keyword">...</span>
find(v007);v007=v007(:).';<span class="keyword">if</span> numel(v000)&lt;(max(v007)+v005-1),v001=<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v007( (v007+v005-1)&gt;numel(v000) )=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isempty(v007),v008=bsxfun_plus(v007 , <span class="keyword">...</span>
(0:(v005-1)).' );v008=v008.';v007=v000(v008);<span class="keyword">end</span>,<span class="keyword">else</span>,v007=[];<span class="keyword">end</span>,v009=[repmat(<span class="string">'1'</span>,1,v005-1) <span class="keyword">...</span>
repmat(<span class="string">'10'</span>,1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);<span class="keyword">if</span> numel(v007)&gt;0,v007=<span class="keyword">...</span>
unique(v007,<span class="string">'rows'</span>);v011=mat2cell(v007,ones(size(v007,1),1),v005);<span class="keyword">for</span> v012=1:numel(v011),v013=<span class="keyword">...</span>
dec2bin(double(v011{v012}))';<span class="keyword">if</span> ~strcmp(v009,v013(v010)),v001=<span class="string">'error'</span>;<span class="keyword">if</span> v003,<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">continue</span>,<span class="keyword">end</span>,v013(v010)=<span class="string">''</span>;<span class="keyword">if</span> ~v004,v014=uint32(bin2dec(v013 ));<span class="keyword">else</span>,v014=<span class="keyword">...</span>
uint32(bin2dec(v013.'));<span class="keyword">end</span>,v000=PatternReplace(v000,v011{v012},v014);<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> v000=unicode_to_UTF8(v001),<span class="keyword">if</span> v001&lt;128,v000=v001;<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">persistent</span> v002,<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v002),v002=struct;v002.limits.lower=hex2dec({<span class="string">'0000'</span>,<span class="string">'0080'</span>,<span class="string">'0800'</span>, <span class="string">'10000'</span>});
v002.limits.upper=hex2dec({<span class="string">'007F'</span>,<span class="string">'07FF'</span>,<span class="string">'FFFF'</span>,<span class="string">'10FFFF'</span>});v002.scheme{2}=<span class="string">'110xxxxx10xxxxxx'</span>;
v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}=<span class="string">'1110xxxx10xxxxxx10xxxxxx'</span>;
v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}=<span class="string">'11110xxx10xxxxxx10xxxxxx10xxxxxx'</span>;
v002.scheme{4}=reshape(v002.scheme{4}.',8,4);<span class="keyword">for</span> v003=2:4,v002.scheme_pos{v003}=<span class="keyword">...</span>
find(v002.scheme{v003}==<span class="string">'x'</span>);v002.bits(v003)=numel(v002.scheme_pos{v003});<span class="keyword">end</span>,<span class="keyword">end</span>,v004=<span class="keyword">...</span>
find(v002.limits.lower&lt;=v001 &amp; v001&lt;=v002.limits.upper);v000=v002.scheme{v004};v005=<span class="keyword">...</span>
v002.scheme_pos{v004};v003=dec2bin(v001,v002.bits(v004));v000(v005)=v003;v000=bin2dec(v000.').';
<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001,v002]=UTF8_to_unicode(v003,v004),<span class="keyword">if</span> nargin&lt;2,v004=[];<span class="keyword">end</span>,v005= nargout==1 ;
v003=uint32(v003);[v002,v006,v007]=UTF8_to_unicode_internal(v003,v005);<span class="keyword">if</span> strcmp(v006,<span class="keyword">...</span>
<span class="string">'success'</span>),v001=true;v000=v002;<span class="keyword">elseif</span> strcmp(v006,<span class="string">'error'</span>),v001=false;<span class="keyword">if</span> v005,error_(v004,v007),<span class="keyword">...</span>
<span class="keyword">end</span>,v000=v003;<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=ExtractCommandsFromLine(v002),v003=[<span class="string">' '</span> v002(1:(end-1))];v004 = <span class="keyword">...</span>
double(v002==<span class="string">'['</span>) - double(v003==<span class="string">']'</span>);v005 = double(v002==<span class="string">'('</span>) - double(v003==<span class="string">')'</span>);v006 = <span class="keyword">...</span>
double(v002==<span class="string">'{'</span>) - double(v003==<span class="string">'}'</span>);v007 = ( cumsum(v004)+cumsum(v005)+cumsum(v006) ) == 0;
v001=find( v007 &amp; ( v002==<span class="string">','</span> | v002==<span class="string">';'</span> ) );<span class="keyword">if</span> ~isempty(v001),<span class="keyword">if</span> <span class="keyword">...</span>
all(ismember(v002(v001(end):end),<span class="string">',; '</span>)),v001(end)=[];<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> isempty(v001),v000={v002};v001=<span class="keyword">...</span>
0;<span class="keyword">else</span>,v000=cell(1+numel(v001),1);v001=[0 v001 numel(v002)+1];<span class="keyword">for</span> v008=1:numel(v000),v000{v008}=<span class="keyword">...</span>
v002( (v001(v008)+1):(v001(v008+1)-1) );<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=get_trace(v002,v001),<span class="keyword">if</span> nargin==0,v002=1;<span class="keyword">end</span>,<span class="keyword">if</span> nargin&lt;2, v001=dbstack;<span class="keyword">end</span>,<span class="keyword">...</span>
v001(1:v002)=[];<span class="keyword">if</span> ~isfield(v001,<span class="string">'file'</span>),<span class="keyword">for</span> v003=1:numel(v001),v004=v001(v003).name;<span class="keyword">if</span> <span class="keyword">...</span>
strcmp(v004(end),<span class="string">')'</span>),v005=strfind(v004,<span class="string">'('</span>);v006=v004( (v005(end)+1):(end-1) );v007=<span class="keyword">...</span>
v004(1:(v005(end)-2));<span class="keyword">else</span>,v007=v004;[v008,v006]=fileparts(v004);<span class="keyword">end</span>,[v008,v001(v003).file]=<span class="keyword">...</span>
fileparts(v007);v001(v003).name=v006;<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">persistent</span> v009,<span class="keyword">if</span> isempty(v009),v009=<span class="keyword">...</span>
exist(<span class="string">'OCTAVE_VERSION'</span>,<span class="string">'builtin'</span>);<span class="keyword">end</span>,<span class="keyword">if</span> v009,<span class="keyword">for</span> v003=1:numel(v001),[v008,v001(v003).file]=<span class="keyword">...</span>
fileparts(v001(v003).file);<span class="keyword">end</span>,<span class="keyword">end</span>,v010=v001;v011=<span class="string">'&gt;'</span>;v000=cell(1,numel(v010)-1);<span class="keyword">for</span> v003=<span class="keyword">...</span>
1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);<span class="keyword">if</span> v003==numel(v010),<span class="keyword">...</span>
v010(v003).file=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> strcmp(v010(v003).file,v010(v003).name),v010(v003).file=<span class="string">''</span>;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isempty(v010(v003).file),v010(v003).file=[v010(v003).file <span class="string">'&gt;'</span>];<span class="keyword">end</span>,v000{v003}=<span class="keyword">...</span>
sprintf(<span class="string">'%c In %s%s (line %d)\n'</span>,v011,v010(v003).file,v010(v003).name,v010(v003).line);v011=<span class="string">' '</span>;
<span class="keyword">end</span>,v000=horzcat(v000{:});<span class="keyword">end</span>
<span class="keyword">function</span> [v000,v001]=validate_print_to__options(v002,v001),<span class="keyword">if</span> nargin&lt;2,v001=struct;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isfield(v002,<span class="string">'print_to_con'</span>),v002.print_to_con=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v002,<span class="string">'print_to_fid'</span>),<span class="keyword">...</span>
v002.print_to_fid=[];<span class="keyword">end</span>,<span class="keyword">if</span> ~isfield(v002,<span class="string">'print_to_obj'</span>),v002.print_to_obj=[];<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
~isfield(v002,<span class="string">'print_to_fcn'</span>),v002.print_to_fcn=[];<span class="keyword">end</span>,v003=true;v000=struct;v004=<span class="keyword">...</span>
v002.print_to_fid;<span class="keyword">if</span> isempty(v004),v000.boolean.fid=false;<span class="keyword">else</span>,v003=false;v000.boolean.fid=true;
v000.fid=v004;<span class="keyword">for</span> v005=1:numel(v004),<span class="keyword">try</span> v006=ftell(v004(v005));<span class="keyword">catch</span>,v006=-1;<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v004(v005)~=1 &amp;&amp; v006==-1,v001.message=[<span class="string">'Invalid print_to_fid parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a valid file identifier or 1.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=v002.print_to_obj;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v004),v000.boolean.obj=false;<span class="keyword">else</span>,v003=false;v000.boolean.obj=true;v000.obj=v004;<span class="keyword">for</span> <span class="keyword">...</span>
v005=1:numel(v004),<span class="keyword">try</span> v007=get(v004(v005),<span class="string">'String'</span> );set( v004(v005),<span class="string">'String'</span>,<span class="string">''</span> );set( <span class="keyword">...</span>
v004(v005),<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,v001.message=[<span class="string">'Invalid print_to_obj parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a handle to an object with a writeable String property.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">...</span>
v004=v002.print_to_fcn;<span class="keyword">if</span> isempty(v004),v000.boolean.fcn=false;<span class="keyword">else</span>,v003=false;<span class="keyword">try</span> <span class="keyword">for</span> v005=<span class="keyword">...</span>
1:numel(v004),<span class="keyword">if</span> ~ismember(class(v004(v005).h),{<span class="string">'function_handle'</span>,<span class="string">'inline'</span>}) || <span class="keyword">...</span>
numel(v004(v005).h)~=1,error(<span class="string">'trigger error'</span>),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">catch</span>,v001.message=<span class="keyword">...</span>
[<span class="string">'Invalid print_to_fcn parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a struct with the h field containing a function handle,'</span>,char(10),<span class="keyword">...</span>
<span class="string">'anonymous function or inline function.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,v004=v002.print_to_con;<span class="keyword">if</span> <span class="keyword">...</span>
isempty(v004),v000.boolean.con=v003;<span class="keyword">else</span>,[v008,v000.boolean.con]=test_if_scalar_logical(v004);
<span class="keyword">if</span> ~v008,v001.message=[<span class="string">'Invalid print_to_con parameter:'</span>,char(10),<span class="keyword">...</span>
<span class="string">'should be a scalar logical.'</span>];v000=[];<span class="keyword">return</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
<span class="keyword">function</span> warning_(v001,varargin),<span class="keyword">persistent</span> v000,<span class="keyword">if</span> isempty(v000),v000=func2str(@warning_);<span class="keyword">end</span>,<span class="keyword">...</span>
<span class="keyword">if</span> isempty(v001),v001=struct;<span class="keyword">end</span>,v001=parse_warning_error_redirect_options(v001);[v002,v003,<span class="keyword">...</span>
v004,v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct(<span class="string">'identifier'</span>,v002,<span class="keyword">...</span>
<span class="string">'message'</span>,v003,<span class="string">'stack'</span>,v004);<span class="keyword">if</span> v001.boolean.con,<span class="keyword">if</span> ~isempty(v002),warning(v002,<span class="string">'%s'</span>,v003),<span class="keyword">else</span>,<span class="keyword">...</span>
warning(v003), <span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">if</span> ~isempty(v002),lastwarn(v003,v002); <span class="keyword">else</span>,lastwarn(v003),<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.boolean.obj,v007=v003;<span class="keyword">while</span> v007(end)==10,v007(end)=[];<span class="keyword">end</span>,<span class="keyword">if</span> any(v007==10),v007=<span class="keyword">...</span>
char2cellstr([<span class="string">'Warning: '</span> v007]);<span class="keyword">else</span>,v007=[<span class="string">'Warning: '</span> v007];<span class="keyword">end</span>,set(v001.obj,<span class="string">'String'</span>,v007),<span class="keyword">...</span>
<span class="keyword">for</span> v008=v001.obj(:).',<span class="keyword">try</span> set(v008,<span class="string">'String'</span>,v007);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid || <span class="keyword">...</span>
v001.boolean.fcn,v009=2;[v005,v004]=get_trace(v009);<span class="keyword">end</span>,<span class="keyword">if</span> v001.boolean.fid,<span class="keyword">for</span> v010=<span class="keyword">...</span>
v001.fid(:).',<span class="keyword">try</span> fprintf(v010,<span class="string">'Warning: %s\n%s'</span>,v003,v005);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">if</span> <span class="keyword">...</span>
v001.boolean.fcn,<span class="keyword">if</span> ismember(v000,{v004.name}),error(<span class="string">'prevent recursion'</span>),<span class="keyword">end</span>,<span class="keyword">for</span> v011=<span class="keyword">...</span>
v001.fcn(:).',<span class="keyword">if</span> isfield(v011,<span class="string">'data'</span>),<span class="keyword">try</span> feval(v011.h,<span class="string">'warning'</span>,v006,v011.data);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">else</span>,<span class="keyword">...</span>
<span class="keyword">try</span> feval(v011.h,<span class="string">'warning'</span>,v006);<span class="keyword">catch</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>,<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% minify
%
% <html><tt style="font-size:0%">Formatted documentation for the minify function.</tt>
% <div style="margin-top:-5em;color:grey">Process Matlab code into a solid block of compact and unreadable but functionally equivalent code.
% </div>
% </html>

%% Description
% <html>
% The likely use cases fall generally under two categories:<br>
% <ol>
%    <li> Attaching code as a dependency to allow your code to run, without having to refer to
%       separate FEX/Github entries. In some such places understanding the attached code is not
%       important, while space is at a premium (e.g. pdf attachments, where large amounts of
%       dependent code would be distracting).</li>
%    <li> Code obfuscation. Since p-code will only run on a subset of Matlab releases (and not at
%       all on GNU Octave), using that will limit compatibility. Additionally, given that the
%       encryption has been broken, this might be a good additional step (or replacement) to hide
%       the function of your code without harming its function.</li>
% </ol>
% The process of compacting Matlab code is split into several steps (steps 3-8 should be performed
% for each function separately and some steps are optional):<br><br>
% <ol>
%    <li> Strip all comments and line continuations.</li>
%    <li> Sort the functions (if there are multiple) in order to keep the entry function(s) at the
%       top of the output.</li>
%    <li> Separate the code and the embedded chars/strings.</li>
%    <li> Parse the code to select only the places where a new variable may be created in the
%       workspace. False positives should be avoided at all costs. False negatives should be
%       avoided, but are not a major issue.</li>
%    <li> Use that (and the list of local functions) to create a dictionary of variable and
%       function names.</li>
%    <li> Remove the entry function from that dictionary and replace every occurrence of a variable
%       or local function with a shorter/pseudonymized one.</li>
%    <li> Replace all double spaces in code with single space.</li>
%    <li> Put the code and chars/strings back together.</li>
%    <li> Merge lines if the result is shorter that a fixed length. A space, comma, or semicolon
%       may be added. Be careful with functions that rely on printing results to the command
%       window by omitting the semicolon, although such functions should probably not be minified
%       in the first place (as the variable names are changed).</li>
% </ol>
% This function was tested on a random sample of m-files from the FileExchange. Some limits were
% imposed on the selection of files: only submissions with 5 downloads or more in the last 30
% days, at most 5 files per submission (taking the first files in the hierarchy, without checking
% if those actually would contain the main function), ignoring functions with fewer than 5 or more
% than 1000 lines (and functions with less than 2 lines of actual code), and ignoring functions
% with lines over 1000 characters long (as those probably contain data, not real code). If
% BeastMode is set to true the size of functions tends to be reduced to about &#8539; of the
% original number of lines. Setting BeastMode to false will increase the variability by a lot, and
% results in file sizes of about half of the original number of lines.
% <br>The compression depends mostly on the amount of comments, typical line length, amount and
% length of chars/strings, and typical variable name length. See the performance section below for
% more precise figures for typical compression rates.
% </html>

%% Syntax
%
%   str_out=minify(str_in)
%   str_out=minify(str_in,BeastMode)
%   str_out=minify(str_in,BeastMode,max_length_after_merge)
%   str_out=minify(str_in,BeastMode,max_length_after_merge,EntryFunctionNames)

%% Output arguments
%
% <html>
% <table border=1>
% <tr><td>
% str_out
% </td><td>
% mx1 cell array with the minified code
% </td></tr>
% </table>
% </html>

%% Input arguments
%
% <html>
% <table border=1>
% <tr><td>
% str_in
% </td><td>
% nx1 cell array of char arrays
% </td></tr>
% <tr><td>
% BeastMode
% </td><td>
% A logical that triggers additional steps to further minify the code. If this input is
% <code>true</code> (or <code>1</code>, <code>'on'</code>, ect), all defaults described below are
% used. <code>false</code> (or an invalid input) will set all fields to <code>false</code>.
% <br>Specific aspects can be set individually by supplying a <code>struct</code> instead. Any
% missing field will be filled with the default.
% <tr><td>
% max_length_after_merge
% </td><td>
% This is the target maximum length (the line length might be exceeded by the original code after
% the removal of the line continuation)
% <br>If <code>max_length_after_merge&lt;10</code>, this value is multiplied by the maximum line
% length preference.
% <br>(if you want more than 10x, you can provide a negative value)
% </td></tr>
% <tr><td>
% EntryFunctionNames
% </td><td>
% This is a cell array or chars with function names that should be kept unchanged. These functions
% will be move to the top if there are multiple functions. This defaults to the first function (if
% any).
% </td></tr>
% <tr><td>
% AlwaysSpaceEllipsis
% </td><td>
% In R2021a the interpretation of an ellipsis changed. Starting from this release
% <code>'...\n\s*'</code> is not gobbled, but it is interpreted as a space. See <a
% href="http://web.archive.org/web/20210504113526/https://www.mathworks.com/help/matlab/release-notes.html#mw_ef23ce50-083b-4ec9-af8c-e8d65d8ce308">this</a>
% section in the release notes.
% <br>This parameter must be either a logical or empty. If true, an ellipsis will be interpreted a
% space (note that this doesn't mean a space will be added). The default will be determined based
% on the behavior of the release calling this function.
% </td></tr>
% </table>
% </html>

%% BeastMode parameters
% <html>
% <table border=1>
% <tr><td>trim_spaces</td><td>
% <code>default=1;</code> Strip leading spaces and remove all double spaces that do not occur
% inside a char or a string.</td></tr>
% <tr><td>compress_to_block</td><td>
% <code>default=0;</code> Attempt to compress the entire input to a single block.
% <br>Setting this to <code>true</code> will cause the resulting code to be incompatible between
% modern Matlab releases and Octave and ML6.5. The reason is that the former require a space
% between <code>'end'</code> and <code>'function'</code>, while the latter require a comma or
% semicolon.</td></tr>
% <tr><td>compress_functions_separately</td><td>
% <code>default=1;</code> Compress each function to a separate block of code.
% <br>If proper detection of nested function is implemented, this will compress each parent
% function including the nested functions to a single block.
% <br>If compress_to_block is set to true, this is ignored.</td></tr>
% <tr><td>keep_original_function_names</td><td>
% <code>default=0;</code> Do not rename local functions.
% <br>This setting can be used if any code uses <code>eval</code> with the name of a local function
% in a <code>char</code> or a <code>string</code>. (you can use
% <code>func2str(@local_function)</code> to work around this issue)</td></tr>
% <tr><td>contains_nested_functions</td><td>
% <code>default=0;</code> Setting this to true will skip the steps that would break nested
% functions.</td></tr>
% </table>
% </html>

%% Example

% You can get the readfile function here: www.mathworks.com/matlabcentral/fileexchange/68780.
try tf=isempty(which(func2str(@readfile)));catch,tf=true;end
if tf,readfile=@(fn)split(fileread(fn),{newline,[char(13) newline]});end
% Read a function to a cellstr.
str=readfile([mfilename '.m']);
% Minify the function.
str=minify(str);
% Generate a function name.
[p,n]=fileparts(tempname);fn_out=[p filesep 'fun_' n '.m'];
% Write the minified function to a file.
fid=fopen(fn_out,'w');fprintf(fid,'%s\n',str{:});fclose(fid);
% Open the result in the editor.
edit(fn_out)

%% Compatibility, version info, and licence
% <html>
% Compatibility considerations:
% <ul>
%    <li> Octave and ML6.5 require a semicolon or comma between <code>'end'</code> and
%       <code>'function'</code>, while newer Matlab releases either require a space or newline.
%       Setting <code>compress_to_block</code> to true will make the resulting code incompatible
%       between the two styles.</li>
%    <li> The command syntax (e.g. <code>warning off all</code>) will be incorrectly parsed. The
%       literal text part of the call will be treated as normal code (so <code>off=false;warning
%       off all</code> will become <code>v000=false;warning v000 all</code>). Consider using the
%       function syntax instead.</li>
%    <li> Support for <code>eval</code> and friends is limited to situation where they don't rely
%       on variable/function names (e.g. if it is used to create an anonymous function). You could
%       use something like <code>func2str(@local_function)</code> to use a local function call
%       inside an <code>eval</code> statement.</li>
%    <li> Nested functions are tricky to extract. It is possible (match up end statements with
%       <code>'if'</code>, <code>'try'</code>, <code>'while'</code>, <code>'for'</code>,
%       <code>'parfor'</code>, and <code>'function'</code>, then confirm every function has an
%       <code>'end'</code> and ignore nested functions while sorting the functions). I don't use
%       them (as they are incompatible with Matlab&nbsp;6.5 and Octave), but it isn't impossible to
%       modify this function. You can set <code>contains_nested_functions</code> to true to turn
%       off the parts that will interfere with nested functions.</li>
%    <li> There is no support for the arguments block. This is not a fundamental issue, it is just
%       not yet implemented in this function. Feel free to suggest the required edits on GitHub.
%       The priority of this issue for me is low.</li>
%    <li> If you use <code>load()</code> without an output argument, that will create variables in
%       your workspace. This function doesn't know the variable names, so that syntax will result
%       in errors. Use the <code>S=load(___);</code> syntax instead.</li>
%    <li>Using <code>save(___)</code> might cause issues if the specific variable is renamed. In a
%       future version of this function it may be possible to protect the variable names in a
%       <code>save</code> call. Currently you should use a function that converts the input
%       variable to a char, e.g. <code>var2str=@(x) inputname(1);</code>.</li>
%    <li> Be careful with the <code>plot(x,y,LineWidth=2)</code> syntax (introduced in R2021a). If
%       you have a variable or local function with the name <code>LineWidth</code>, this result in
%       <code>LineWidth</code> being replaced by the shortened name. It might be possible to adapt
%       this function to detect such use cases and avoid replacements. Feel free to suggest the
%       required edits on GitHub. The priority of this issue for me is low.</li>
%    <li> The interpretation of a line continuation <a
%       href="http://web.archive.org/web/20210504113526/https://www.mathworks.com/help/matlab/release-notes.html#mw_ef23ce50-083b-4ec9-af8c-e8d65d8ce308">changed</a>
%       in R2021a: "Previously, if an ellipsis followed an operator inside of a matrix or cell
%       array, it caused the operator to be treated as unary. Ellipses will now be treated as a
%       space in all cases."
%       <br>This function will return unambiguous code, but the interpretation of the input will be
%       controled by the AlwaysSpaceEllipsis parameter. The default behavior follows the default
%       from the release used.</li>
% </ul>
% </html>
% 
% <html>
% <table>
% <tr>
% <td> Test suite result </td>
% <td style="border:2px solid black;"> Windows XP/7/10 </td>
% <td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
% <td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2021a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2020b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2020a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2018a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2015a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2013b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2012b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2011a </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2010b </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2010a </td>
% <td> <it>W7 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab R2007b </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab 7.1 (R14SP3) </td>
% <td> <it>XP : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Matlab 6.5 (R13) </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 6.2.0 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 5.2.0 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it>Pass</it> </td>
% <td> <it></it> </td>
% </tr>
% <tr>
% <td style="border:2px solid black;"> Octave 4.4.1 </td>
% <td> <it>W10 : Pass</it> </td>
% <td> <it></it> </td>
% <td> <it>Pass</it> </td>
% </tr>
% </table>
% </html>
%
%  Version: 1.0.1
%  Date:    2020-12-23
%  Author:  H.J. Wisselink
%  Licence: CC by-nc-sa 4.0 ( https://creativecommons.org/licenses/by-nc-sa/4.0 )
%  Email = 'h_j_wisselink*alumnus_utwente_nl';
%  Real_email = regexprep(Email,{'*','_'},{'@','.'})

%% Performance
% <html>
% The benchmarking function used to generate the results below can be found
% <a href=https://web.archive.org/web/20210519084221/https://cdn-117.anonfiles.com/l7dcV7w3ua/4d2c7f86-1621414338/aaa___minify___performance_test.m>here</a>.
% <br>The test results shown in the tables below are normalized to the results of the newest
% Matlab release on Windows, since the performace is strongly dependent on the specific
% computer running the test. To allow absolute comparisons as well the results in that cell
% are shown in seconds.
% <br>
% <br>Note that every result apart from those under Windows 10 was obtained in a VM, so the
% performance is likely an underestimation of the true performance.
% <br>
% <br>A random sample of 1000 m-files was downloaded from the FEX around 2021/05/18.<br>With BeastMode, 50% of functions are between 10.0 and 18.0% of original size (median 13%).<br>Without BeastMode, 50% of functions are between 38.4 and 65.1% of original size (median 52%).<br>The timing test below shows results for fewer files and only uses BeastMode.<br>
% <br>
% <table>
% <tr>
% <td> Test suite result </td>
% <td style="border:2px solid black;"> Windows XP/7/10 </td>
% <td style="border:2px solid black;"> Ubuntu 20.04 LTS </td>
% <td style="border:2px solid black;"> MacOS 10.15 Catalina </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2021a </td>
% <td> (W10) <br> 4.858&nbsp;s </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2020b </td>
% <td> (W10) <br> 102&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2020a </td>
% <td> (W10) <br> 108&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2018a </td>
% <td> (W10) <br> 112&nbsp;% </td>
% <td> 108&nbsp;% </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2015a </td>
% <td> (W10) <br> 162&nbsp;% </td>
% <td> 179&nbsp;% </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2013b </td>
% <td> (W10) <br> 153&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2012b </td>
% <td> (W10) <br> 153&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2011a </td>
% <td> (W10) <br> 148&nbsp;% </td>
% <td> 147&nbsp;% </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2010b </td>
% <td>  </td>
% <td> 189&nbsp;% </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2010a </td>
% <td> (W7) <br> 150&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab R2007b </td>
% <td> (W10) <br> 143&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab 7.1 (R14SP3) </td>
% <td> (XP) <br> 171&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Matlab 6.5 (R13) </td>
% <td> (W10) <br> 218&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Octave 6.2.0 </td>
% <td> (W10) <br> 540&nbsp;% </td>
% <td>  </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Octave 5.2.0 </td>
% <td> (W10) <br> 499&nbsp;% </td>
% <td> 347&nbsp;% </td>
% <td>  </td>
% </tr>
% <tr>
% <td style="border:2px solid black;vertical-align:middle"> Octave 4.4.1 </td>
% <td> (W10) <br> 484&nbsp;% </td>
% <td>  </td>
% <td> 783&nbsp;% </td>
% </tr>
% </table>
% </html>

%% Test suite
%
% This tester is included so you can test if your own modifications would introduce any bugs. These
% tests form the basis for the compatibility table above.
% 
% Note that some of the functions in this tester might be different from the functions included in
% the actual function. Usually this is done to allow triggering of certain errors.
% 
% To save space, the tester function below was minified. The full tester function (including all comments) can be found <https://web.archive.org/web/20210519084431/https://cdn-112.anonfiles.com/X9d8Vawcu3/011bdc76-1621414466/aaa___minify___test.m here>.

%  Test the most important stages separately, and check if the output of the whole chain is stable.
% 
% Pass:    passes all tests
% Partial: [no partial passing condition]
% Fail:    fails any test
%
function v000=aaa___minify___test(varargin),v000='pass';global ...
HJW___test_suit___debug_hook_data,HJW___test_suit___debug_hook_data=[];v001='comment stripping';
[v002,v003]=comment_stripper_test_data;try v004=[];v005 = StripComments(v002);v006=false;catch ...
v004;if isempty(v004),v004=lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,...
if v006 || ~isequal(v005,v003),if nargout>0,v000='fail';return,else,...
error(['test did not match expected output (' v001 ')']),end,end,v001='char/string detection';
[v002,v003]=char_and_code_split_test_data;try v004=[];v007=SplitCodeAndChar(v002);
v003(cellfun('isempty',v003))={''};v007( cellfun('isempty',v007 ))={''};v006=false;catch v004;
if isempty(v004),v004=lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,if ...
v006 || ~isequal(v007,v003),if nargout>0,v000='fail';return,else,...
error(['test did not match expected output (' v001 ')']),end,end,v001=...
'function/variable name detection';[v002,v008,v009]=generate_fill_workspace;try v004=[];v010=...
ListVariables(v002);v011=ListLocalFunctions(v002);v006=false;catch v004;if isempty(v004),v004=...
lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,if v006 || (~isequal(v010,...
v008) || ~isequal(v011,v009) ),if nargout>0,v000='fail';return,else,...
error(['test did not match expected output (' v001 ')']),end,end,v002=[generate_fill_workspace;
char_and_code_split_test_data;comment_stripper_test_data];v012=...
'omnibus test part %d did not match expected hash\n(expected %s, returned %s)';v013=1;v004=[];
v014='';v015='';try v016=minify(v002,true,80,{'fill_workspace','fun_loc_1'},' ');v014=...
ComputeNonCryptHash(v016,128,'-v2');v015='45A0B7E551B62340E286BA5E683EAEF4';v006=false;catch ...
v004;if isempty(v004),v004=lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,...
if v006 || ~strcmp(v014,v015),if nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),...
end,end,v013=2;v004=[];v014='';v015='';v017=struct('compress_to_block',true);try v016=...
minify(v002,v017,80,{'fill_workspace','fun_loc_1'},' ');v014=ComputeNonCryptHash(v016,128,...
'-v2');v015='933B7389C25AD11AD94C2C83F046688F';v006=false;catch v004;if isempty(v004),v004=...
lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,if v006 || ~strcmp(v014,...
v015),if nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),end,end,v013=3;v004=[];
v014='';v015='';v017=true;HJW___test_suit___debug_hook_data=struct('action','return','data',...
{{true}});try v016=minify(v002,v017,80,[],' ');v014=ComputeNonCryptHash(v016,128,'-v2');v015=...
'1CC9CB35AF3DCB66994638850B108D2D';v006=false;catch v004;if isempty(v004),v004=lasterror;end,...
disp(v004.message),disp(v004.identifier),v006=true;end,if v006 || ~strcmp(v014,v015),if ...
nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),end,end,v013=4;v004=[];v014='';
v015='';try v016=minify(v002,true,80,{'fill_workspace'},' ');v014=ComputeNonCryptHash(v016,128,...
'-v2');v015='4E58F69325634C36FD628F32AC5C4298';v006=false;catch v004;if isempty(v004),v004=...
lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,if v006 || ~strcmp(v014,...
v015),if nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),end,end,v013=5;v004=[];
v014='';v015='';try v016=minify(v002,false,80,{'fill_workspace'},' ');v014=...
ComputeNonCryptHash(v016,128,'-v2');v015='B985E20AFB7B5FB62630EE0561BF254F';v006=false;catch ...
v004;if isempty(v004),v004=lasterror;end,disp(v004.message),disp(v004.identifier),v006=true;end,...
if v006 || ~strcmp(v014,v015),if nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),...
end,end,v013=6;v004=[];v014='';v015='';v017=struct('keep_original_function_names',true);try ...
v016=minify(v002,v017,80,{'fill_workspace'},' ');v014=ComputeNonCryptHash(v016,128,'-v2');v015=...
'1CC9CB35AF3DCB66994638850B108D2D';v006=false;catch v004;if isempty(v004),v004=lasterror;end,...
disp(v004.message),disp(v004.identifier),v006=true;end,if v006 || ~strcmp(v014,v015),if ...
nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),end,end,v013=7;v004=[];v014='';
v015='';v017=struct('contains_nested_functions',true);try v016=minify(v002,v017,80,...
{'fill_workspace'},' ');v014=ComputeNonCryptHash(v016,128,'-v2');v015=...
'05DBBE2C6772AFE90068983326831695';v006=false;catch v004;if isempty(v004),v004=lasterror;end,...
disp(v004.message),disp(v004.identifier),v006=true;end,if v006 || ~strcmp(v014,v015),if ...
nargout>0,v000='fail';return,else,error(v012,v013,v015,v014),end,end,...
disp('test finished successfully'),if nargout==0,clear,end,end
function v000=unicode_to_char(v001,v002),persistent v003,if isempty(v003),v003 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if nargin==1,v002=~v003;end,if v002,if ...
all(v001<65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));else,[v004,v005,v006]=...
unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=unicode_to_UTF16(v004(v007));
v008=uint16(v008);v000(v006==v007)={v008};end,v000=cell2mat(v000);end,if ~v003,v000=char(v000);
end,else,if all(v001<128),v000=char(v001);v000=reshape(v000,1,numel(v000));else,[v004,v005,...
v006]=unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=...
unicode_to_UTF8(v004(v007));v008=uint8(v008);v000(v006==v007)={v008};end,v000=cell2mat(v000);
v000=char(v000);end,end,end
function v000=SetDefault_end_function_char(v000),persistent v001,if nargin>0, v001=v000;end,if ...
isempty(v001),if ifversion('<',7,'Octave','>',0),v001=',';else, v001=' ';end,end,if nargout>0,...
v000=v001;end,end
function v000=comma_or_semicolon(v001),v000=repmat(',',numel(v001),1);v002=...
cumsum(cellfun('prodofsize',v001));v001=horzcat(v001{:});v003 = double(v001=='[') - ...
double(v001==']');v004 = double(v001=='{') - double(v001=='}');v005 = ( ...
cumsum(v003)+cumsum(v004) );v006=v005(v002)~=0;v000(v006)=';';v006=ismember(v002,strfind(v001,...
'endfunction')+2);v000(v006)=SetDefault_end_function_char;end
function v000=parse_warning_error_redirect_options(v000),if ~isfield(v000,'boolean'),...
v000.boolean=struct;end,if ~isfield(v000.boolean,'con') || isempty(v000.boolean.con),...
v000.boolean.con=false;end,if ~isfield(v000.boolean,'fid') || isempty(v000.boolean.fid),...
v000.boolean.fid=isfield(v000,'fid');end,if ~isfield(v000.boolean,'obj') || ...
isempty(v000.boolean.obj),v000.boolean.obj=isfield(v000,'obj');end,if ~isfield(v000.boolean,...
'fcn') || isempty(v000.boolean.fcn),v000.boolean.fcn=isfield(v000,'fcn');end,end
function v002=transposing_scalar_string_is_fixed,persistent v000,if isempty(v000),v001='""''';
v000=isequal(StripComments(v001),v001);if ~v000,error('This should have been fixed already.'),...
end,end,v002=v000;end
function v000=GetMaxLineLengthPref(varargin),persistent v001 v002,if isempty(v001),...
v001.isOctave=exist('OCTAVE_VERSION', 'builtin');if ~v001.isOctave,v001.settings=ifversion('>=',...
'R2018a');v001.com.mathworks=ifversion('>=','R13');v001.R13=ifversion('==','R13');end,if ...
v001.isOctave,v002=80;elseif ifversion('<=','R2010b'),v002=75;else,v002=80;end,end,if ...
v001.isOctave,v000=0;elseif v001.settings,v003 = settings;v000=...
v003.matlab.editor.displaysettings.linelimit.LineColumn.ActiveValue;elseif v001.com.mathworks,...
v000=com.mathworks.services.Prefs.getIntegerPref('EditorRightTextLineLimit');elseif v001.R13,...
v000=com.mathworks.services.Prefs.getIntegerPref('EditorMaxCommentWidth');else,v000=80;end,v000=...
double(v000);if isempty(v000) || v000==0,v000=v002;end,end
function v000=ifversion(v001,v002,v003,v004,v005),persistent v006 v007 v008,if isempty(v006),...
v008=exist('OCTAVE_VERSION', 'builtin');v006=version;v009=strfind(v006,'.');if numel(v009)~=1,...
v006(v009(2):end)='';v009=v009(1);end,v006=[str2double(v006(1:(v009-1))) ...
str2double(v006((v009+1):end))];v006=v006(1)+v006(2)/100;v006=round(100*v006);v007={ 'R13' 605;
'R13SP1' 605;'R13SP2' 605;'R14' 700;'R14SP1' 700;'R14SP2' 700;'R14SP3' 701;'R2006a' 702;
'R2006b' 703;'R2007a' 704;'R2007b' 705;'R2008a' 706;'R2008b' 707;'R2009a' 708;'R2009b' 709;
'R2010a' 710;'R2010b' 711;'R2011a' 712;'R2011b' 713;'R2012a' 714;'R2012b' 800;'R2013a' 801;
'R2013b' 802;'R2014a' 803;'R2014b' 804;'R2015a' 805;'R2015b' 806;'R2016a' 900;'R2016b' 901;
'R2017a' 902;'R2017b' 903;'R2018a' 904;'R2018b' 905;'R2019a' 906;'R2019b' 907;'R2020a' 908;
'R2020b' 909;'R2021a' 910};end,if v008,if nargin==2,warning('HJW:ifversion:NoOctaveTest',...
['No version test for Octave was provided.',char(10),...
'This function might return an unexpected outcome.']),if isnumeric(v002),v010=...
0.1*v002+0.9*fix(v002);v010=round(100*v010);else,v011=ismember(v007(:,1),v002);if sum(v011)~=1,...
warning('HJW:ifversion:NotInDict','The requested version is not in the hard-coded list.'),v000=...
NaN;return,else,v010=v007{v011,2};end,end,elseif nargin==4,[v001,v010]=deal(v003,v004);v010=...
0.1*v010+0.9*fix(v010);v010=round(100*v010);else,[v001,v010]=deal(v004,v005);v010=...
0.1*v010+0.9*fix(v010);v010=round(100*v010);end,else,if isnumeric(v002),v010=...
0.1*v002+0.9*fix(v002);v010=round(100*v010);else,v011=ismember(v007(:,1),v002);if sum(v011)~=1,...
warning('HJW:ifversion:NotInDict','The requested version is not in the hard-coded list.'),v000=...
NaN;return,else,v010=v007{v011,2};end,end,end,switch v001,case '==', v000= v006 == v010;case ...
'<' , v000= v006 < v010;case '<=', v000= v006 <= v010;case '>' , v000= v006 > v010;case '>=', ...
v000= v006 >= v010;end,end
function [v000,v001,v002]=ListLocalFunctions(v003),v004=isa(v003,'char');if v004,v003={v003};
end,[v005,v003]=SplitCodeAndChar(v003);v006=warning('off','MATLAB:REGEXP:deprecated');v000=...
cell(0);v001=zeros(0);v002=zeros(0);v007=0;for v008=1:numel(v003),[v009,v010]=...
ExtractCommandsFromLine(v003{v008});for v011=1:numel(v009),v012=...
ListLocalFunctions_helper(v009{v011});if ~isempty(v012),v007=v007+1;v000{v007,1}=v012;v001(v007,...
1)=v008;v002(v007,1)=v010(v011);end,end,end,if numel(v000)==0,v000={'function'};end,if v004,...
v000=v000{1};end,warning(v006);end
function v000=ListVariables(v001),v002=warning('off','MATLAB:REGEXP:deprecated');persistent ...
v003,if isempty(v003),try unique([1 1 2],'stable');v003=false;catch,v003=true;end,end,v000=...
cell(0);v004=0;v005={'varargin';'varargout'};v006=2;for v007=1:numel(v001),v008=...
ExtractCommandsFromLine(v001{v007});for v009=1:numel(v008),[v000,v004,v005,v006]=...
ListVariables_ParseLine(v008{v009},v000,v004,v005,v006);end,end,if ~v003,v000=unique(v000,...
'stable');else,[v010,v011]=unique(v000);v000=v000(sort(v011));end,v000(ismember(v000,v005))=[];
v000(ListVariables_HasHandleRef(v000,v001))=[];warning(v002),end
function [v000,v001,v002,v003]=ListVariables_ParseLine(v004,v000,v001,v002,v003),persistent ...
v005,if isempty(v005),v005 = exist('OCTAVE_VERSION', 'builtin') ~= 0;end,v006=[' ' v004];v007=...
'\s*function[\s\[](.*)';v008=regexp(v004,v007,'once');if ~isempty(v008);v006=regexprep(v004,...
v007,'$1', 'tokenize');v009='(^)|(\]?\s*=)\s*(([a-zA-Z]+[_a-zA-Z0-9]*))[^_a-zA-Z]';[v010,v011]=...
regexp(v006,v009);try v012=v006(v010(1):v011(1));v012=regexprep(v012,...
'[^_a-zA-Z0-9]*([_a-zA-Z0-9]*)[^_a-zA-Z0-9]*','$1','tokenize');catch,v012=regexprep(v006,v009,...
'$1','tokenize');end,v006=regexprep(v006,['\]?\s*=\s*' v012 '\s*\((.*)\)'],',$1]', 'tokenize');
v006=strrep(v006,v012,'');if isempty(v006),return,end;[v000,v001]=...
ListVariables_ParseOutputVariables(v006,v000,v001);return;end;v013=zeros(size(v006));v006 =...
strrep(v006,'}{','__');v014 ='{';v013( v006==v014 )= 1;v015='}';v013([false v006==v015])=-1;
v013=cumsum(v013);v006(v013(1:(end-1))>0)='';v013=zeros(size(v006));v014 ='(';v013( v006==v014 ...
)= 1;v015=')';v013([false v006==v015])=-1;v013=cumsum(v013);v006(v013(1:(end-1))>0)='';v016=...
{'[;,\s]' , '\s+(([a-zA-Z][a-zA-Z0-9_]*\s*)*)'};v017= [v016{1} 'persistent' v016{2}];if v005;if ...
isempty(regexp(v006,v017, 'once'));else;v018=regexprep(v006,v017,'$1');[v000,v001]=...
ListVariables_ParseOutputVariables(v018,v000,v001);v006=regexprep(v006,v017,'');end;else;[v019,...
v020,v018]=regexp(v006,v017);for v021=numel(v018):-1:1;[v000,v001]=...
ListVariables_ParseOutputVariables(v006(v018{v021}(1):v018{v021}(2)),v000,v001);
v006(v019(v021):v020(v021))='';end;end;v017= [v016{1} 'global' v016{2}];if v005;if ...
isempty(regexp(v006,v017, 'once'));else;v018=regexprep(v006,v017,'$1');[v002,v003]=...
ListVariables_ParseOutputVariables(v018,v002,v003);v006=regexprep(v006,v017,'');end;else;[v019,...
v020,v018]=regexp(v006,v017);for v021=numel(v018):-1:1;[v002,v003]=...
ListVariables_ParseOutputVariables(v006(v018{v021}(1):v018{v021}(2)),v002,v003);
v006(v019(v021):v020(v021))='';end;end;v006=strrep(v006,'==','<');v006=strrep(v006,'~=','<');
v006=strrep(v006,'>=','<');v006=strrep(v006,'<=','<');for v022=numel(v006):-1:1;v008=find(v006==...
'=');if isempty(v008);break;else;v006(v008(end):end)='';v008={max(find(v006=='[')), ...
max([find(v006==',') find(v006==';')]), 1};v008=[v008{:}];v008=v008(1);v023=v006(v008(end):end);
v006(v008(end):end)='';v023=regexprep(v023,'\s+for\s+','');v023=regexprep(v023,'\s+try\s+','');
[v000,v001]=ListVariables_ParseOutputVariables(v023,v000,v001);end;end;end
function v000=ListVariables_HasHandleRef(v001,v002),v002=sprintf('%s ',v002{:});v003=...
'@[a-zA-Z]+[_a-zA-Z0-9]*';v004=regexp_outkeys(v002,v003,'match');v004=strrep(v004,'@','');v000=...
ismember(v001,v004);end
function v000=ListLocalFunctions_helper(v001),v000='';v002='\s*function[\s\[](.*)';v003=...
regexp(v001,v002,'once');if ~isempty(v003);v004=regexprep(v001,v002,'$1', 'tokenize');v004=...
v004( max([1 1+strfind(v004,'=')]) : min([strfind(v004,'(')-1 numel(v004)]) );v000=strrep(v004,...
' ','');end;end
function [v000,v001]=ListVariables_ParseOutputVariables(v002,v000,v001),[v003,v004,v005]=...
regexp(v002,'\[(.*)\]|((.*)?)');v002=v002(v005{1}(1):v005{1}(2));v006 = ...
'[^a-zA-Z_\.]([a-zA-Z][a-zA-Z0-9_]*)';v002=[' ' v002];[v003,v004,v005]=regexp(v002,v006);for ...
v007=1:numel(v005),v001=v001+1;v000{v001,1}=v002(v005{v007}(1):v005{v007}(2));end,end
function v000=MergeLineContinuation(v000,v001),persistent v002,if isempty(v002),v002=...
numel(eval(sprintf('[1 -...\n2]')))==1;end,v003=v002;if nargin==2 && ~isempty(v001),v003=v001;
end,for v004 = (numel(v000)-1):-1:1,v005=false;if numel(v000{v004})>=3,v005=...
strcmp(v000{v004}((end-2):end),'...');end,if v005,v000{v004}((1+regexp(v000{v004},...
'\s*...$')):end)='';if v000{v004}(end)=='.',v000{v004}(end)='';end,v006=...
find(~isspace(v000{v004+1}));if ~isempty(v006)&&v006(1)>1,v006=v006(1);else,v006=1;end,if v003,...
if numel(v000{v004})>=1 && any(v000{v004}(end)== ',;*/^\@<>&|='),v007='';else,v007=' ';end,else,...
if numel(v000{v004})>=1 && any(v000{v004}(end)=='+-~,;*/^\@<>&|='),v007='';else,v007=' ';end,...
end,if v006==1,v000{v004}=[v000{v004} v007 v000{v004+1} ];v000(v004+1)=[];else,v000{v004}=...
[v000{v004} v007 v000{v004+1}(v006:end)];v000(v004+1)=[];end,end,end,end
function v000=MergeShortLines(v000,v001,v002),if nargin<3,v002=true;end,v000(cellfun('isempty',...
v000))=[];v003=comma_or_semicolon(v000);for v004=(numel(v000)-1):-1:1,v005=v000{v004};v006=...
v000{v004+1};if strcmp(v005((max(1,end-2)):max(1,end)),'...'),v005((end-2):end)='';v003(v004)=...
' ';end,v006=regexprep(v006,'^\s*','');if v002,if strcmp(v006(1:(min(end,8))),'function'),...
continue,end,end,if ~strcmp(v005(end),';') && ~strcmp(v005(end),','),v005=[v005 v003(v004)];end,...
if strcmp(v005((max(1,end-3)):max(1,end-1)),'try'),v005(end)=' ';end,if numel(v005)+numel(v006) ...
<= v001,v000{v004}=[v005 v006];v000(v004+1)=[];end,end,end
function [v000,v001,v002]=generate_fill_workspace,v000={ ...
'%This file lists most possible syntaxes that result in workspace variables.';
'%All variables named var__ should be found, but none of the old_var__ variables.';
'function [var01,var02]=fill_workspace(var03,var04,var05)';
' function varargout=fun_loc_1(varargin);';'[var06,var07]=fun_ext_1(old_var1)';
'var08=fun_ext_2(old_var2);[var09,var10]=fun_ext_3(old_var3);';'var11.field1=fun_ext_4;';
'var12.(old_var4)=fun_ext_5;';'persistent var13;var14=fun_ext_6,persistent var15;';
';persistent var16 var17';'global var_glo_01';'persistent var18;[old_var5];global var_glo_02;';
'old_var6==old_var7';'[old_var8 old_var9]';'if old_var10';'    1+1;';'end';
'  for var19=1:numel(old_var_11),end,if fun_ext_7(old_var11),var20=fun_ext_8(old_var12);end';
'if fun_ext_9(old_var13)';'end';'old_var14,function fun_loc_2';'function[var21]=fun_loc_3';
'function var22=fun_loc_4';'function [var23,var24]=fun_loc_5,fun_ext_10(old_var15)';
'persistent persistent_var_25';'persistent var_26_persistent';'persistent var_persistent_27';
'persistent_var28=old_var_16;';
'function [var29,var30]=fun_loc_6,[old_var17(old_var18)];function var31=fun_loc_7';
'@fun_loc_6'};v001={'var01';'var02';'var03';'var04';'var05';'var06';'var07';'var08';'var09';
'var10';'var11';'var12';'var13';'var14';'var15';'var16';'var17';'var18';'var19';'var20';'var21';
'var22';'var23';'var24';'persistent_var_25';'var_26_persistent';'var_persistent_27';
'persistent_var28';'var29';'var30';'var31'};v002={'fill_workspace';'fun_loc_1';'fun_loc_2';
'fun_loc_3';'fun_loc_4';'fun_loc_5';'fun_loc_6';'fun_loc_7'};end
function v000=FillBeastModeStruct(v001),persistent v002 v003,if isempty(v002),v002=struct;
v002.trim_spaces=true;v002.compress_to_block=false;v002.compress_functions_separately=true;
v002.keep_original_function_names=false;v002.contains_nested_functions=false;v003=v002;v004=...
fieldnames(v003);for v005=1:numel(v004),v003.(v004{v005})=false;end,end,if ~isa(v001,'struct'),...
[v006,v001]=test_if_scalar_logical(v001);if ~v006 || v001,v000=v002;return,else,v000=v003;
return,end,end,v000=v002;v004=fieldnames(v001);for v005=1:numel(v004),[v006,v007]=...
test_if_scalar_logical(v001.(v004{v005}));if v006,v000.(v004{v005})=v007;else,v000.(v004{v005})=...
true;end,end,end
function v000=SortFunctions(v001,v002),[v003,v004,v005]=ListLocalFunctions(v001);if ...
numel(v004)<=1,v000={v001};return,end,if any(v005>1),v006=unique(v004(v005>1)).';v006=...
v006(end:-1:1);for v007=v006,v008=v001{v007};v009=v005(v004==v007).';v009(v009==0)=[];v010=...
diff([0 v009 numel(v008)]);v008=mat2cell(v008,1,v010).';v001=[v001(1:(v007-1));v008;
v001((v007+1):end)];end,[v003,v004]=ListLocalFunctions(v001);end,[v011,v012]=ismember(v003,...
v002);[v013,v014]=sort(v003(~v011));v012(~v011)=sum(v011)+v014;[v013,v012]=sort(v012);v000=...
cell(numel(v004),1);v004=[v004;numel(v001)+1];for v015=1:numel(v000),v000{v015}=...
v001(v004(v015):(v004(v015+1)-1));end,v000=v000(v012);end
function [v000,v001]=char_and_code_split_test_data,v000={'data=[bit1'';bit2'';bit3'';bit4''];';
'data=[bit1'';''foo%'';bit2'';bit3'';bit4''];';'data=[bit1'';"foo%";bit2'';bit3'';bit4''];';
'data=[bit1'';''foo'';''bar'';bit2.'';bit3'';bit4''];';
'''foo'';''bar'';bit2.'';bit3'';[bit4''];';' ''foo'';''bar'';bit2.'';bit3'';[bit4''];';
'data=[bit1'';"foo%".'';bit2'';bit3'';bit4''];';'data=[bit1'';"foo%"'';bit2'';bit3'';bit4''];'};
v001={'data=[bit1'';bit2'';bit3'';bit4''];',[],[],[],[];'data=[bit1'';','''foo%''',...
';bit2'';bit3'';bit4''];',[],[];'data=[bit1'';','"foo%"',';bit2'';bit3'';bit4''];',[],[];
'data=[bit1'';','''foo''',';','''bar''',';bit2.'';bit3'';bit4''];';[],'''foo''',';','''bar''',...
';bit2.'';bit3'';[bit4''];';' ','''foo''',';','''bar''',';bit2.'';bit3'';[bit4''];';
'data=[bit1'';','"foo%"','.'';bit2'';bit3'';bit4''];',[],[];'data=[bit1'';','"foo%"',...
''';bit2'';bit3'';bit4''];',[],[]};if ~transposing_scalar_string_is_fixed,v000(8)=[];v001(8,:)=...
[];end,end
function v000=minify(v000,v001,v002,v003,v004,v005),persistent v006,if isempty(v006),v006 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if nargin<1,error('not enough inputs');end,if ...
nargin<2 || isempty(v001),v001=true;end,if nargin<3 || isempty(v002),v002=1.5;end,if nargin<5,...
v004=[];end,if nargin<6,v005='';end,v007=false;try v007=isequal(v000,cellstr(v000));catch,end,...
if ~v007,error('first input must be a cellstr');end,v001=FillBeastModeStruct(v001);if v002<10,...
v002=ceil(abs(v002)*GetMaxLineLengthPref);end,SetDefault_end_function_char(v005);v000=...
StripComments(v000);v000=MergeLineContinuation(v000,v004);if numel(v000)==0,return,end,if ...
nargin<4 || isempty(v003),v003=ListLocalFunctions(v000{1});end,if debug_hook(false),v003=...
ListLocalFunctions(v000);end,v003=cellstr(v003);if ~v001.contains_nested_functions,v008=...
SortFunctions(v000,v003);else,v008={v000};end,if v001.keep_original_function_names,v009=cell(0,...
2);else,[v010,v011]=SplitCodeAndChar(vertcat(v008{:}));v009=ListLocalFunctions(v011);
v009(ismember(v009,v003))=[];for v012=1:numel(v009),v009{v012,2}=sprintf('f%02d',v012-1);end,if ...
v001.contains_nested_functions,v013=ListVariables(v011);for v012=1:numel(v013),v013{v012,2}=...
sprintf('v%03d',v012-1);end,end,end,persistent v014,if isempty(v014),v014=ifversion('>=',7,...
'Octave','>',0);end,for v015=1:numel(v008),v000=v008{v015};[v016,v011]=SplitCodeAndChar(v000);
v017=ListVariables(v011);if v001.contains_nested_functions,v018=ismember(v013(:,1),v017);v019=...
[v009;v013(v018,:)];else,for v012=1:numel(v017),v017{v012,2}=sprintf('v%03d',v012-1);end,v019=...
[v009;v017];end,if numel(v019)==0,v019=cell(0);end,v020=size(v016,1)==1;if v020,v016(2,1)={' '};
end,v021=~cellfun('isempty',v016);v021(:,2:2:end)=false;if v014,for v022=1:size(v019,1),v023=...
['(^|(?<=[^a-zA-Z0-9_\.]))(' v019{v022,1} ')(?=[^a-zA-Z0-9_]|$)'];for v024=find(v021).',...
v016{v024}=regexprep(v016{v024},v023,v019{v022,2});end,end,else,for v022=1:size(v019,1),v023=...
['([^a-zA-Z0-9_\.])(' v019{v022,1} ')([^a-zA-Z0-9_])'];for v024=find(v021).',v000=[' ' ...
v016{v024} ' '];v000=regexprep(v000,v023,['$1' v019{v022,2} '$3'],'tokenize');v000=...
regexprep(v000,v023,['$1' v019{v022,2} '$3'],'tokenize');v016{v024}=v000(2:(end-1));end,end,end,...
if v001.trim_spaces,for v024=find(v021).',v025=inf;while v025~=0,v026=length(v016{v024});
v016{v024}=strrep(v016{v024},'  ',' ');v027=length(v016{v024});v025=v026-v027;end,end,for v028=...
1:size(v021,1),if numel(v016{v028,1})>=1 && strcmp(v016{v028,1}(1),' '),v016{v028,1}(1)='';end,...
end,end,if v020,v016(2,:)=[];end,for v028=1:size(v016,1),v029=v016(v028,:);if v006,...
v029(cellfun('isempty',v029))={''};end,v016{v028,1}=[v029{:}];end,v000=v016(:,1);v008{v015}=...
v000;end,if v001.compress_to_block,if numel(v003)>1,v030=cell(1,1+numel(v003));
v030(1:numel(v003))=v008(1:numel(v003));if numel(v008)>numel(v003),v031=...
v008((numel(v003)+1):end);v030{end}=vertcat(v031{:});else,v030(end)=[];end,for v012=...
1:numel(v030),v030{v012}=CompressFunctionBody(v030{v012},v002);end,v000=vertcat(v030{:});else,...
v000=vertcat(v008{:});v000=CompressFunctionBody(v000,v002);end,elseif ...
v001.compress_functions_separately,for v012=1:numel(v008),if numel(v008{v012})==1,continue,end,...
v008{v012}=CompressFunctionBody(v008{v012},v002);end,v000=vertcat(v008{:});else,v000=...
vertcat(v008{:});end,end
function v000=AddMissing(v001,v000),v002=fieldnames(v001);v003=fieldnames(v000);for v004=...
find(~ismember(v002,v003)).',v005=v002{v004};v000.(v005)=v001.(v005);end,end
function v000=bsxfun_plus(v001,v002),try v000=v001+v002;catch,try v000=bsxfun(@plus,v001,v002);
catch,v003=size(v001); v004=size(v002);v001=repmat(v001,max(1,v004./v003)); v002=repmat(v002,...
max(1,v003./v004));v000=v001+v002;end,end,end
function v000=cast_to_uint16_vector(v000,v001),if isa(v000,'uint16'),v002='uint16';v003=...
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];return,...
end,v000=cast_to_uint16_vector__cell({v000},v001);v000([end-1 end])=[];end
function v000=cast_to_uint16_vector__integer(v000,v001),v002=size(v000).';v000=v000(:);
persistent v003,if isempty(v003),v003=ifversion('>=','R2010b','Octave','>',0);end,v004=...
class(v000);v005=~v001.cast_int64_double && v003 && v004(end)=='4';if ~v005,if ...
any(abs(double(v000(:)))>2^52),warning_(v001,'HJW:ComputeNonCryptHash:int64rounding',...
['int64 and uint64 will be rounded pre-R2010b, resulting in rounding.',char(10),...
'This will result in a hash that is different from newer releases.']),end,end,if v005,if ...
v004(1)~='u',v006=v000>0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=...
uint64(v000(v006))+uint64(v007)+1;v000=v008;end,elseif v004(1)~='u',v000=...
double(v000)-double(eval([v004 '(-inf)']));else,v000=double(v000);end,switch v004(end),case '8',...
if mod(numel(v000),2),v000(end+1)=0;end,v000=reshape(v000,[],2);v000=v000(:,1)*255+v000(:,2);
v000=uint16(v000);case '6',v000=uint16(v000);case '2',v009=floor(v000/2^16);v009=v009.';v010=...
mod(v000,2^16); v010=v010.';v000=[v009;v010];v000=uint16(v000(:));case '4',v011=v000;v012=...
mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';v013=mod(v011,2^16);v011=v011-v013;
v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=v011-v010;v011=v011/2^16;v010=v010.';v009=...
mod(v011,2^16); v009=v009.';v000=[v009;v010;v013;v012];v000=uint16(v000(:));end,v000=[v000;
uint16(v004.');uint16(mod(v002,2^16))];end
function v000=cast_to_uint16_vector__char(v000,v001),persistent v002,if isempty(v002),v002 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if v002 && v001.re_encode_char,v003 = size(v000,1)==...
numel(v000);if v003,v000=v000.';end,v000=cellstr(v000);for v004=1:numel(v000),v000{v004}=...
unicode_to_char(UTF8_to_unicode(v000{v004},v001.print_to),true);end,v005=cellfun('length',v000);
v006=max(v005);for v004=find(v005<v006),v000{v004}( (numel(v000{v004})+1) : v006)=uint16(' ');
end,v000=cell2mat(v000);if v003,v000=v000.';end,end,v007=size(v000).';v000=v000(:);v000=...
uint16(v000);v000=[v000;uint16(mod(v007,2^16))];end
function v000=cast_to_uint16_vector__string(v000,v001),if v001.string_to_cellstr,v000=...
cellstr(v000);v000=cast_to_uint16_vector__cell(v000,v001);else,v000=char(v000);v000=...
cast_to_uint16_vector__char(v000,v001);end,end
function [v000,v001]=comment_stripper_test_data,v000=...
{'%just a few examples of hard to parse syntaxes';'''%".''''...''%foo';'%{';'bar';'%}';'"foo"';
'bar.''''';'[foo...';'    bar]';'[foo...foobar';'    bar]';'""""''%''...';'foo';'[""]''.''%foo';
'[1 2';'    3 4]';'%{foo}';'bar';'   %foo'};v001={ '''%".''''...''';'"foo"';'bar.''''';
'[foo...';'    bar]';'[foo...';'    bar]';'""""''';'foo';'[""]''.''';'[1 2';'    3 4]';'bar'};
end
function v000=cast_to_uint16_vector__cell(v000,v001),v002=size(v000).';v000=v000(:);for v003=...
1:numel(v000),if numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);continue,end,switch class(v000{v003}),case {'double','single'},v000{v003}=...
cast_to_uint16_vector__floats(v000{v003});case 'logical',v000{v003}=...
cast_to_uint16_vector__logical(v000{v003});case {'uint8','uint16','uint32','uint64','int8',...
'int16','int32','int64'},v000{v003}=cast_to_uint16_vector__integer(v000{v003},v001);case 'char',...
v000{v003}=cast_to_uint16_vector__char(v000{v003},v001);case 'string',v000{v003}=...
cast_to_uint16_vector__string(v000{v003},v001);case 'cell',v000{v003}=...
cast_to_uint16_vector__cell(v000{v003},v001);case 'struct',v000{v003}=...
cast_to_uint16_vector__struct(v000{v003},v001);case {'gpuArray','tall'},v000{v003}=...
cast_to_uint16_vector__cell({gather(v000{v003})},v001);otherwise,error_(v001.print_to,...
'HJW:cast_to_uint16_vector:nosupport','Unsupported data type in nested variable'),end,end,v000=...
cell2mat(v000);v000=[v000;uint16(mod(v002,2^16))];end
function v000=cast_to_uint16_vector__logical(v000),v001=size(v000).';v000=v000(:);if ...
mod(numel(v000),16),v000(16*ceil(numel(v000)/16))=0;end,v002=uint16(2.^(15:-1:0))';v000=...
uint16(reshape(v000,16,[]));try v000=v000.*v002;catch,v000=double(v000).*repmat(double(v002),[1 ...
size(v000,2)]);v000=uint16(v000);end,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,...
2^16))];end
function v000=cast_to_uint16_vector__floats(v000),v001=size(v000).';v002=class(v000);[v003,...
v004]=typecast_double_uint64(double(v000));v005=mod(v003,2^16);v003=v003-v005;v003=v003/2^16;
v004=v004.';v006 =mod(v003,2^16);v003=v003-v006; v003=v003/2^16;v006=v006.';v007 =mod(v003,...
2^16);v003=v003-v007; v003=v003/2^16;v007=v007.';v008 =mod(v003,2^16); v008=v008.';v000=[v008;
v007;v006;v004];v000=uint16(v000(:));v000=[v000;uint16(v002.');uint16(mod(v001,2^16))];end
function v000=PatternReplace(v001,v002,v003),v000=v001(:)';if numel(v002)==0,v004=...
false(size(v001));elseif numel(v003)>numel(v002),error('not implemented (padding required)'),...
else,v004=true(size(v001));for v005=1:numel(v002),v006=find(v001==v002(v005));v006=v006-v005+1;
v006(v006<1)=[];v007=false(size(v004));v007(v006)=true;v004= v004 & v007;if ~any(v004),break,...
end,end,end,v006=find(v004);if ~isempty(v006),for v005=1:numel(v003),v000(v006+v005-1)=...
v003(v005);end,if numel(v003)==0,v005=0;end,if numel(v002)>v005,v006=v006(:);v008=...
(v005+1):numel(v002);v009=bsxfun_plus(v006,v008-1);v000(v009(:))=[];end,end,end
function v000=cast_to_uint16_vector__struct(v000,v001),v002=size(v000).';v000=v000(:);v003=...
fieldnames(v000);v004=cell(2,numel(v003));for v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,...
v005}={v000.(v003{v005})};end,v000=cast_to_uint16_vector__cell(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];end
function varargout=regexp_outkeys(v000,v001,varargin),if nargin<3,...
error('HJW:regexp_outkeys:SyntaxError','No supported syntax used: at least 3 inputs expected.'),...
end,if ~(ischar(v000) && ischar(v001)),error('HJW:regexp_outkeys:InputError',...
'All inputs must be char vectors.'),end,persistent v002,if isempty(v002),v002.match = ...
ifversion('<','R14','Octave','<',4);v002.split = ifversion('<','R2007b','Octave','<',4);end,...
varargout=cell(size(varargin));for v003=1:(nargin-2),if ~ischar(varargin{v003}),...
error('HJW:regexp_outkeys:InputError','All inputs must be char vectors.'),end,switch ...
lower(varargin{v003}),case 'match',if v002.match,[v004,v005]=regexp(v000,v001);v006=cell(1,...
numel(v004));for v007=1:numel(v004),v006{v007}=v000(v004(v007):v005(v007));end,else,v006=...
regexp(v000,v001,'match');end,varargout{v003}=v006;case 'split',if v002.split,[v004,v005]=...
regexp(v000,v001);v008=cell(1,numel(v004)+1);v009=[v004 numel(v000)+1];v010=[0 v005];for v007=...
1:numel(v009),v008{v007}=v000((v010(v007)+1):(v009(v007)-1));end,else,v008= regexp(v000,v001,...
'split');end,varargout{v003}=v008;otherwise,v011=fieldnames(v002);v012=...
['Extra regexp output type not implemented,',char(10),'only the following',...
' types are implemented:',char(10),sprintf('%s, ',v011{:})];v012((end-1):end)='';
error('HJW:regexp_outkeys:NotImplemented',v012),end,end,end
function v000=char2cellstr(v001,v002),v003=isa(v001,'char');v001=int32(v001);if nargin<2,if ...
any(v001==13),v001=PatternReplace(v001,int32([13 10]),int32(-10));v001(v001==13)=-10;end,...
v001(v001==10)=-10;else,for v004=1:numel(v002),v001=PatternReplace(v001,int32(v002{v004}),...
int32(-10));end,end,v005=[0 find(v001==-10) numel(v001)+1];v000=cell(numel(v005)-1,1);for v004=...
1:numel(v000),v006=(v005(v004 )+1);v007=(v005(v004+1)-1);v000{v004}=v001(v006:v007);end,if v003,...
for v004=1:numel(v000),v000{v004}= char(v000{v004});end,else,for v004=1:numel(v000),v000{v004}=...
uint32(v000{v004});end,end,end
function [v000,v001]=SplitCodeAndChar(v002),persistent v003,if isempty(v003),v003 = ...
exist('OCTAVE_VERSION', 'builtin') ~= 0;end,v000=cell(numel(v002),1);v001=cell(numel(v002),1);
for v004=1:numel(v002),v005=SplitLineToCodeAndChar(v002{v004});v000(v004,1:2:(2*size(v005,2)))=...
v005(1,:);v000(v004,2:2:(2*size(v005,2)-1))=v005(2,1:(end-1));for v006=1:(size(v005,2)-1),v007=...
v005{2,v006}(1);v005{2,v006}=[v007 repmat('_',1,numel(v005{2,v006})-2) v007];end,if v003,...
v005(cellfun('isempty',v005))={''};end,v005=[v005{:}];v001{v004}=v005;end,end
function v000=clean_double_equals(v000,v001),persistent v002,if isempty(v002),v002=...
find(ismember(v001(:,1),'='));end,v003= v000==v002 ;v003= v003(1:(end-1)) & v003(2:end) ;
v000(v003)=0;end
function [v000,v001,v002]=SplitLines(v003),v003=char(v003);v002=false;if ~( any(v003==10) || ...
any(v003==13) ),if ispc,v001=char([13 10]);else,v001=char(10);end,v000={v003};else,v004=...
find(v003==10 | v003==13);v004=v004(1:min(2,end));if numel(v004)==2 && ( diff(v004)~=1 || ...
v003(v004(1))==v003(v004(2)) ),v004(2)=[];end,v001=v003(v004);if numel(v003)>1,v002=strcmp(v001,...
v003((end-numel(v001)+1):end));end,v000=regexp_outkeys(v003,v001,'split');v000=v000(:);end,end
function [v000,v001]=getSplitIndex(v002,v003,v004,v005),v000=[];v001=[];if ~any(v002),return,...
end,persistent v006,if isempty(v006),v006=cell2mat(v005(:,2)).'/100;end,v000=find(v002);if v003,...
v007=max(50,v004*v006(v002(v000)));[v008,v009]=max(v000-v007);else,[v008,v009]=min(v000);end,...
v000=v000(v009);v001=v002(v000);if v003,v010=v005{v001,4}+3*v005{v001,3};if v000>(v004+v010),...
v002=v002(1:(v000-1));[v000,v001]=getSplitIndex(v002,v003,v004,v005,v006);end,end,end
function v000=ComputeNonCryptHash(v001,varargin),if nargin<1,...
error('HJW:ComputeNonCryptHash:InputIncorrect','At least 1 input required.'),end,if nargin==2 ...
&& isa(varargin{1},'struct') && varargin{1}.SkipInputParse,v002=varargin{1};else,[v003,v002,...
v004]=ComputeNonCryptHash_parse_inputs(varargin{:});if ~v003,rethrow(v004),end,end,...
v002.print_to=v002.print_2__options;v005=v002.HashLength;v006=v002.Version;try v004=[];v001=...
cast_to_uint16_vector(v001,v002);catch v004;if isempty(v004),v004=lasterror;end,if ...
strcmp(v004.identifier,'MATLAB:nomem'),error_(v002.print_to,v004),else,if isfield(v002,'debug') ...
&& v002.debug,v007=sprintf('\n[original error: %s %s]',v004.identifier,v004.message);else,v007=...
'';end,error_(v002.print_to,'HJW:ComputeNonCryptHash:UnwindFailed',...
['The nested input contains an unsupported data type.' v007]),end,end,if mod(numel(v001),...
v005/16),v008=uint16(1:v005/16).'; v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];end,if ...
v006==1,v001=ComputeNonCryptHash_shuffle_uint16(v001);v001=...
ComputeNonCryptHash_uint16_to_logical(v001);v001=xor(v001,reshape(v001,[],16).');else,v001=...
ComputeNonCryptHash_shuffle_uint16(v001);v001=ComputeNonCryptHash_uint16_to_logical(v001);v001=...
circshift_by_col(v001);end,v001=mod(sum(reshape(v001,v005,[]),2),2);v001=...
ComputeNonCryptHash_logical_to_uint16(v001);if v002.isSaltCall,v000=v001;return,end,v001=...
ComputeNonCryptHash_add_salt(v001,v002);v000=ComputeNonCryptHash_dec2hex(v001);v000=...
reshape(v000.',1,[]);end
function v000=circshift_by_col(v000),persistent v001,v002=size(v000);if isempty(v001) || ...
any(size(v001)<v002) || isempty(v001{v002(1),v002(2)}),[v003,v004]=meshgrid(1:size(v000,2),...
1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=sub2ind(size(v000),v005,v003);if ...
prod(v002)<=1000,v001{v002(1),v002(2)}=v006;end,else,v006=v001{v002(1),v002(2)};end,v000=...
v000(v006);end
function v000=ComputeNonCryptHash_add_salt(v000,v001),v002=16*numel(v000);v003=v001;
v003.Version=1; v003.HashLength=v002;v003.SkipInputParse=1; v003.isSaltCall=1;v004=...
ComputeNonCryptHash(v000,v003);v004=ComputeNonCryptHash_shuffle_uint16_inv(v004);if ...
v001.Version>1,v004=v004(end:-1:1);end,v000=mod(double(v000).*double(v004),1+2^16);v000=...
uint16(v000);end
function v000=ComputeNonCryptHash_dec2hex(v001),persistent v002,if isempty(v002),v002=...
upper(dec2hex(0:(-1+2^16),4));end,v001=double(v001)+1;v000=v002(v001,:);end
function v000=ComputeNonCryptHash_logical_to_uint16(v000),if mod(numel(v000),16),...
v000(16*ceil(numel(v000)/16))=0;end,v001=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
try v000=v000.*v001;catch,v000=double(v000).*repmat(double(v001),[1 size(v000,2)]);v000=...
uint16(v000);end,v000=uint16(sum(v000,1)).';end
function v000=ComputeNonCryptHash_shuffle_uint16(v000),v001=65537;v002=479001600;v000 = ...
uint16(mod(double(v000) * v002 , v001));end
function v000=ComputeNonCryptHash_shuffle_uint16_inv(v000),v001=65537;v002=1919;v000=...
uint16(mod(double(v000) * v002,v001));end
function [v000,v001,v002,v003]=parse_warning_error_redirect_inputs(varargin),if nargin==1,if ...
isa(varargin{1},'struct') || isa(varargin{1},'MException'),v004=varargin{1};try v002=v004.stack;
v003=get_trace(0,v002);catch,[v003,v002]=get_trace(3);end,v000=v004.identifier;v001=...
v004.message;v005=...
'Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback(';if ...
isa(v004,'struct') && numel(v001)>numel(v005) && strcmp(v005,v001(1:numel(v005))),...
v001(1:find(v001==10,1))='';end,else,[v003,v002]=get_trace(3);[v000,v001]=deal('',varargin{1});
end,else,[v003,v002]=get_trace(3);if ~isempty(strfind(varargin{1},'%')),v000='';v006=...
varargin(2:end);v001=sprintf(varargin{1},v006{:});else,v000=varargin{1};v001=varargin{2};if ...
nargin>3,v006=varargin(3:end);v001=sprintf(v001,v006{:});end,end,end,end
function v000=SplitLineToCodeAndChar(v001),v001=[' ' v001 ' '];v002=DetermineParseState(v001);
v003=diff(v002==0);v004=[1 find(v003==1)+1 ];v005=[ find(v003==-1) numel(v002)];v000=cell(2,...
numel(v004));for v006=1:numel(v004),v007=v004(v006);v008=v005(v006);v000{1,v006}=...
v001(v007:v008);v007=v005(v006)+1;v008=v004(min(v006+1,end))-1;v000{2,v006}=v001(v007:v008);end,...
v000{1, 1 }( 1 )='';v000{1,end}(end)='';end
function v000=CompressFunctionBody(v001,v002),persistent v003,if isempty(v003),v003={ ';', 0,...
false,false, 0;',', 0,true ,false, 0;' ', 5,true ,false, 0;'@',10,true ,false,-1;'=',10,true ,...
false, 0};end,v002=v002-4;v004=MergeShortLines(v001,inf,false);v004=v004{1};v005=...
SplitLineToCodeAndChar(v004);v006=cell(size(v005));for v007=1:size(v006,2),v008=...
zeros(size(v005{1,v007}));for v009=1:size(v003,1),v008(v005{1,v007}==v003{v009,1})=v009;end,...
v006{1,v007}=v008;v006{2,v007}=zeros(size(v005{2,v007}));end,v006=horzcat(v006{:});v006=...
clean_double_equals(v006,v003);v000=cell(ceil(numel(v006)/v002),1);v010=0;v011=v004;v012=NaN;
while ~isempty(v011),v010=v010+1;if numel(v011)==v012,warning('infinite loop found'),keyboard,...
warning('infinite loop found'),keyboard,end,if numel(v011)<=v002 || ~any(v006),v000{v010}=v011;
break,end,[v013,v014]=getSplitIndex(v006(1:v002),true,v002,v003);if isempty(v013),[v013,v014]=...
getSplitIndex(v006,false,v002,v003);end,v013=v013+v003{v014,5};v000{v010}=v011(1:v013);v015=...
false;if v003{v014,4},v015=true;v016= ' ' ;else,v016='';end,if v003{v014,3},v015=true;v017=...
'...';else,v017='';end,if v015,v000{v010}=[v000{v010} v016 v017];end,v012=numel(v011);
v011(1:v013)='';v006(1:v013)=[];end,v000((v010+1):end)=[];end
function v000 = StripComments(v001),v002=isa(v001,'string');if v002,v001=cellstr(v001);end,if ...
isa(v001,'cell'),for v003=1:numel(v001),if (ndims(v001{v003}) > 2) || (any(size(v001{v003}) > ...
0) && (size(v001{v003}, 1) ~= 1)),error('HJW:StripComments:InvalidInput',...
'All character arrays must be row vectors.');end,end,end,v004=ischar(v001);if v004,[v001,v005,...
v006]=SplitLines(v001);else,v005='';v006=false;for v003=1:numel(v001),[v001{v003},v007,v008]=...
SplitLines(v001{v003});v006=v006 || v008;if numel(v001{v003})>1,v005=v007;end,end,if ...
isempty(v005),v005=v007;end,v001=vertcat(v001{:});end,v009=cell(1,2);v010=warning('off',...
'REGEXP:multibyteCharacters');for v003=1:2,if v003==1,v011='\{';else,v011='\}';end,v009{v003}=...
regexp(v001,['^[^\S]*%' v011 '[^\S]*$']);if isa(v009{v003},'double'),v009{v003}=v009(v003);end,...
v009{v003}=~cellfun('isempty',v009{v003});end,warning(v010);v009=cumsum(v009{1}-v009{2})>0 | ...
v009{2};v001(v009)=[];v000 = v001;for v003 = 1:numel(v000),v012 = v000{v003};v012 = ...
StripComments__line(v012);v013=isspace(v012);if all(v013),v014=0;else,v014=find(~v013);end,if ...
~isempty(v014)&&v014(end)<numel(v012),v012((v014(end)+1):end)=[];end,v000{v003} = v012;end,...
v000(cellfun('isempty',v000))=[];if v004,v000 = sprintf(['%s' v005],v000{:});if ~v006,try ...
v000((end-numel(v005)+1):end) = '';catch,end,end,elseif v002,v000=string(v000);end,end
function v000=StripComments__line(v001),[v002,v003]=SplitLines(v001);if numel(v002)>1,for v004=...
1:numel(v002),v002{v004}=StripComments__line(v002{v004});end,v002=v002.';v002(2,1:(end-1))=...
{v003};v002{end}='';v000=horzcat(v002{:});if isa(v001,'string'),v000=string(v000);end,return,...
else,v001=v002{1};end,v005=DetermineParseState(v001);v006=strfind(v001,'%');v007=strfind(v001,...
'...');v008=[v006(v005(v006)==0) 3+v007(v005(v007)==0)];if ~isempty(v008),v001(min(v008):end)=...
'';end,v000=v001;end
function v000=ComputeNonCryptHash_uint16_to_logical(v000),persistent v001,if isempty(v001),v001=...
dec2bin(0:(-1+2^16))=='1';v001=v001.';end,v000=double(v000)+1;v000=v001(:,v000);end
function [v000,v001]=test_if_scalar_logical(v001),persistent v002,if isempty(v002),v002={true,...
false;1,0;'on','off';'enable','disable';'enabled','disabled'};try v002(end+1,:)=...
eval('{"on","off"}');catch,end,end,v000=true;try if isa(v001,'char') || isa(v001,'string'),try ...
v001=lower(v001);catch,end,end,for v003=1:size(v002,1),for v004=1:2,if isequal(v001,v002{v003,...
v004}),v001=v002{1,v004};return,end,end,end,if isa(v001,'matlab.lang.OnOffSwitchState'),v001=...
logical(v001);return,end,catch,end,v000=false;end
function v000=ComputeNonCryptHash_DefaultsByVersion(v000),if ~isfield(v000,...
're_encode_char_on_Octave'),v000.re_encode_char=v000.Version>=2;end,if ~isfield(v000,...
'string_to_cellstr'),v000.string_to_cellstr=v000.Version>=2;if ~isfield(v000,...
'cast_int64_double'),v000.cast_int64_double=v000.Version==1;end,end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs(varargin),v000=true;v002=struct;
persistent v003,if isempty(v003),v003=struct;v003.HashLength=256;v003.Version=2;
v003.VersionFlag='-v2';v003.SkipInputParse=false;v003.isSaltCall=false;v004=struct;
v003.print_to_con=true;v004.print_to_con=v003.print_to_con;v003.print_to_fid=[];
v004.print_to_fid=v003.print_to_fid;v003.print_to_obj=[];v004.print_to_obj=v003.print_to_obj;
v003.print_to_fcn=[];v004.print_to_fcn=v003.print_to_fcn;v003.print_2__default_options=v004;
v003.print_2__options=validate_print_to__options(v004);end,if nargin==0,v001=...
ComputeNonCryptHash_DefaultsByVersion(v003);return,end,if nargin==1,switch class(varargin{1}),...
case {'char','string'},v001=AddMissing(v003,struct('VersionFlag',char(varargin{1})));case ...
'struct',v001=AddMissing(v003,varargin{1});otherwise,v001=AddMissing(v003,struct('HashLength',...
varargin{1}));end,[v001,v002,v000]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);if ...
v000,v001=ComputeNonCryptHash_DefaultsByVersion(v001);end,return,end,try [v001,v002,v005]=...
ComputeNonCryptHash_parse_inputs__UnwindToStruct( struct,v002,~v000,varargin{:});v000=~v005;
catch,v002.identifier='HJW:ComputeNonCryptHash:InputFail';v002.message=...
'Input parsing failed. Maybe a parameter has been entered twice.';v000=false;end,if ~v000,...
return,else ,v001=AddMissing(v003,v001);end,[v001,v002,v000]=...
ComputeNonCryptHash_parse_inputs__ValidateInputs(v001);if v000,v001=...
ComputeNonCryptHash_DefaultsByVersion(v001);end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__ValidateInputs(v000),v002=true;v001=...
struct;try v003=str2double(v000.VersionFlag(3:end));if isnan(v003) || round(v003)~=v003 || ...
v003>2,error('trigger');end,v000.Version=v003;catch,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message=...
'Version input incorrect. Must be ''-v1'', ''-v2''.';v002=false;return,end,v004=v000.HashLength;
if numel(v004)~=1 || ~isnumeric(v004) || mod(v004,16)~=0 || v004<16,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message=...
'Second input (hash length) must be a multiple of 16.';v002=false;return,end,for v005=...
fieldnames(v000.print_2__default_options),if ~isequal(v000.(v005{1}),...
v000.print_2__default_options.(v005{1})),[v006,v001]=validate_print_to__options(v000);if ...
isempty(v006),v001.identifier='HJW:ComputeNonCryptHash:PrintToIncorrect';v002=false;return,end,...
v000.print_2__options=v006;break,end,end,end
function varargout=debug_hook(varargin),global HJW___test_suit___debug_hook_data,if ...
isempty(HJW___test_suit___debug_hook_data),varargout=varargin;return,end,v000=...
HJW___test_suit___debug_hook_data(1);HJW___test_suit___debug_hook_data(1)=[];switch v000.action,...
case 'return',varargout=v000.data;case 'warning',varargout=varargin;warning(v000.data{:}),case ...
'error',error(v000.data{:}),case 'warning_',varargout=varargin;warning_(v000.data{:}),case ...
'error_',error_(v000.data{:}),end,end
function [v000,v001,v002]=ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,...
varargin),if v002 || numel(varargin)==0,return,end,v003=varargin{1};if isa(v003,'struct'),v004=...
fieldnames(v000);v005=fieldnames(v003);v006=unique([v004;v005]);if numel(v004)+numel(v005) ~= ...
numel(v006),v002=true;return,end,v000=AddMissing(v000,v003);varargin(1)=[];elseif isa(v003,...
'char') || isa(v003,'string'),try if isa(v003,'string'),v003=char(v003);end,if strcmpi('-v',...
v003(1:2)),if isfield(v000,'VersionFlag'),error('trigger'),end,v000.VersionFlag=v003;
varargin(1)=[];else,if isfield(v000,v003),error('trigger'),end,v000.(v003)=varargin{2};
varargin(1:2)=[];end,catch,v002=true;return,end,else,if isfield(v000,'HashLength'),v002=true;
return,end,v000.HashLength=v003;varargin(1)=[];end,[v000,v001,v002]=...
ComputeNonCryptHash_parse_inputs__UnwindToStruct(v000,v001,v002,varargin{:});end
function v000=DetermineParseState(v001),v001=[' ' v001 ' '];v002=strfind(v001,'''');v003=...
strfind(v001,'"');v000=zeros(size(v001));for v004=sort([v002 v003]),if v000(v004)==-1,continue,...
end,if strcmp(v001(v004),''''),if v000(v004)==5,continue,end,if v000(v004)==2,if ...
strcmp(v001(v004+1),''''),v000(v004+1)=-1;else,v000(v004)=3;v000((v004+1):end)=0;end,else,if ...
v000(v004-1)~=3 && ~isempty(regexp(v001(v004-1),'[\]\)}.\w''"]'));else;v000(v004)=1;
v000((v004+1):end)=2;end;end;else;if v000(v004)==2,continue,end;if v000(v004)==5;if ...
strcmp(v001(v004+1),'"');v000(v004+1)=-1;else;v000(v004)=6;v000((v004+1):end)=0;end;else;
v000(v004)=4;v000((v004+1):end)=5;end;end;end;v000([1 end])=[];end
function error_(v001,varargin),persistent v000,if isempty(v000),v000=func2str(@error_);end,if ...
isempty(v001),v001=struct;end,v001=parse_warning_error_redirect_options(v001);[v002,v003,v004,...
v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct('identifier',v002,'message',...
v003,'stack',v004);if v001.boolean.obj,v007=v003;while v007(end)==10,v007(end)='';end,if ...
any(v007==10),v007=char2cellstr(['Error: ' v007]);else,v007=['Error: ' v007];end,for v008=...
v001.obj(:).',try set(v008,'String',v007);catch,end,end,end,if v001.boolean.fid,for v009=...
v001.fid(:).',try fprintf(v009,'Error: %s\n%s',v003,v005);catch,end,end,end,if v001.boolean.fcn,...
if ismember(v000,{v004.name}),error('prevent recursion'),end,for v010=v001.fcn(:).',if ...
isfield(v010,'data'),try feval(v010.h,'error',v006,v010.data);catch,end,else,try feval(v010.h,...
'error',v006);catch,end,end,end,end,rethrow(v006),end
function [v000,v001]=typecast_double_uint64(v002),[v003,v004]=log2(v002);v005 =...
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=...
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=...
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008 & v002>0)=...
9218868437227405312;v000(v008 & v002<0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=...
0;v001(v008)=0;end
function v000=unicode_to_UTF16(v001),if v001<65536,v000=v001;return,end,v002=double(v001)-65536;
v002=dec2bin(v002,20);v000=bin2dec(['110110' v002(1:10);'110111' v002(11:20)]).';end
function [v000,v001,v002]=UTF8_to_unicode_internal(v000,v003),v001='success';v002=...
struct('identifier','HJW:UTF8_to_unicode:notUTF8','message','Input is not UTF-8.');persistent ...
v004,if isempty(v004),v004 = exist('OCTAVE_VERSION', 'builtin') ~= 0;end,if any(v000>255),v001=...
'error';if v003,return,end,elseif all(v000<128),return,end,for v005=4:-1:2,v006=...
bin2dec([repmat('1',1,v005) repmat('0',1,8-v005)]);v007=v000>=v006 & v000<256;if any(v007),v007=...
find(v007);v007=v007(:).';if numel(v000)<(max(v007)+v005-1),v001='error';if v003,return,end,...
v007( (v007+v005-1)>numel(v000) )=[];end,if ~isempty(v007),v008=bsxfun_plus(v007 , ...
(0:(v005-1)).' );v008=v008.';v007=v000(v008);end,else,v007=[];end,v009=[repmat('1',1,v005-1) ...
repmat('10',1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);if numel(v007)>0,v007=...
unique(v007,'rows');v011=mat2cell(v007,ones(size(v007,1),1),v005);for v012=1:numel(v011),v013=...
dec2bin(double(v011{v012}))';if ~strcmp(v009,v013(v010)),v001='error';if v003,return,end,...
continue,end,v013(v010)='';if ~v004,v014=uint32(bin2dec(v013 ));else,v014=...
uint32(bin2dec(v013.'));end,v000=PatternReplace(v000,v011{v012},v014);end,end,end,end
function v000=unicode_to_UTF8(v001),if v001<128,v000=v001;return,end,persistent v002,if ...
isempty(v002),v002=struct;v002.limits.lower=hex2dec({'0000','0080','0800', '10000'});
v002.limits.upper=hex2dec({'007F','07FF','FFFF','10FFFF'});v002.scheme{2}='110xxxxx10xxxxxx';
v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}='1110xxxx10xxxxxx10xxxxxx';
v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}='11110xxx10xxxxxx10xxxxxx10xxxxxx';
v002.scheme{4}=reshape(v002.scheme{4}.',8,4);for v003=2:4,v002.scheme_pos{v003}=...
find(v002.scheme{v003}=='x');v002.bits(v003)=numel(v002.scheme_pos{v003});end,end,v004=...
find(v002.limits.lower<=v001 & v001<=v002.limits.upper);v000=v002.scheme{v004};v005=...
v002.scheme_pos{v004};v003=dec2bin(v001,v002.bits(v004));v000(v005)=v003;v000=bin2dec(v000.').';
end
function [v000,v001,v002]=UTF8_to_unicode(v003,v004),if nargin<2,v004=[];end,v005= nargout==1 ;
v003=uint32(v003);[v002,v006,v007]=UTF8_to_unicode_internal(v003,v005);if strcmp(v006,...
'success'),v001=true;v000=v002;elseif strcmp(v006,'error'),v001=false;if v005,error_(v004,v007),...
end,v000=v003;end,end
function [v000,v001]=ExtractCommandsFromLine(v002),v003=[' ' v002(1:(end-1))];v004 = ...
double(v002=='[') - double(v003==']');v005 = double(v002=='(') - double(v003==')');v006 = ...
double(v002=='{') - double(v003=='}');v007 = ( cumsum(v004)+cumsum(v005)+cumsum(v006) ) == 0;
v001=find( v007 & ( v002==',' | v002==';' ) );if ~isempty(v001),if ...
all(ismember(v002(v001(end):end),',; ')),v001(end)=[];end,end,if isempty(v001),v000={v002};v001=...
0;else,v000=cell(1+numel(v001),1);v001=[0 v001 numel(v002)+1];for v008=1:numel(v000),v000{v008}=...
v002( (v001(v008)+1):(v001(v008+1)-1) );end,end,end
function [v000,v001]=get_trace(v002,v001),if nargin==0,v002=1;end,if nargin<2, v001=dbstack;end,...
v001(1:v002)=[];if ~isfield(v001,'file'),for v003=1:numel(v001),v004=v001(v003).name;if ...
strcmp(v004(end),')'),v005=strfind(v004,'(');v006=v004( (v005(end)+1):(end-1) );v007=...
v004(1:(v005(end)-2));else,v007=v004;[v008,v006]=fileparts(v004);end,[v008,v001(v003).file]=...
fileparts(v007);v001(v003).name=v006;end,end,persistent v009,if isempty(v009),v009=...
exist('OCTAVE_VERSION','builtin');end,if v009,for v003=1:numel(v001),[v008,v001(v003).file]=...
fileparts(v001(v003).file);end,end,v010=v001;v011='>';v000=cell(1,numel(v010)-1);for v003=...
1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);if v003==numel(v010),...
v010(v003).file='';end,if strcmp(v010(v003).file,v010(v003).name),v010(v003).file='';end,if ...
~isempty(v010(v003).file),v010(v003).file=[v010(v003).file '>'];end,v000{v003}=...
sprintf('%c In %s%s (line %d)\n',v011,v010(v003).file,v010(v003).name,v010(v003).line);v011=' ';
end,v000=horzcat(v000{:});end
function [v000,v001]=validate_print_to__options(v002,v001),if nargin<2,v001=struct;end,if ...
~isfield(v002,'print_to_con'),v002.print_to_con=[];end,if ~isfield(v002,'print_to_fid'),...
v002.print_to_fid=[];end,if ~isfield(v002,'print_to_obj'),v002.print_to_obj=[];end,if ...
~isfield(v002,'print_to_fcn'),v002.print_to_fcn=[];end,v003=true;v000=struct;v004=...
v002.print_to_fid;if isempty(v004),v000.boolean.fid=false;else,v003=false;v000.boolean.fid=true;
v000.fid=v004;for v005=1:numel(v004),try v006=ftell(v004(v005));catch,v006=-1;end,if ...
v004(v005)~=1 && v006==-1,v001.message=['Invalid print_to_fid parameter:',char(10),...
'should be a valid file identifier or 1.'];v000=[];return,end,end,end,v004=v002.print_to_obj;if ...
isempty(v004),v000.boolean.obj=false;else,v003=false;v000.boolean.obj=true;v000.obj=v004;for ...
v005=1:numel(v004),try v007=get(v004(v005),'String' );set( v004(v005),'String','' );set( ...
v004(v005),'String',v007);catch,v001.message=['Invalid print_to_obj parameter:',char(10),...
'should be a handle to an object with a writeable String property.'];v000=[];return,end,end,end,...
v004=v002.print_to_fcn;if isempty(v004),v000.boolean.fcn=false;else,v003=false;try for v005=...
1:numel(v004),if ~ismember(class(v004(v005).h),{'function_handle','inline'}) || ...
numel(v004(v005).h)~=1,error('trigger error'),end,end,catch,v001.message=...
['Invalid print_to_fcn parameter:',char(10),...
'should be a struct with the h field containing a function handle,',char(10),...
'anonymous function or inline function.'];v000=[];return,end,end,v004=v002.print_to_con;if ...
isempty(v004),v000.boolean.con=v003;else,[v008,v000.boolean.con]=test_if_scalar_logical(v004);
if ~v008,v001.message=['Invalid print_to_con parameter:',char(10),...
'should be a scalar logical.'];v000=[];return,end,end,end
function warning_(v001,varargin),persistent v000,if isempty(v000),v000=func2str(@warning_);end,...
if isempty(v001),v001=struct;end,v001=parse_warning_error_redirect_options(v001);[v002,v003,...
v004,v005]=parse_warning_error_redirect_inputs(varargin{:});v006=struct('identifier',v002,...
'message',v003,'stack',v004);if v001.boolean.con,if ~isempty(v002),warning(v002,'%s',v003),else,...
warning(v003), end,else,if ~isempty(v002),lastwarn(v003,v002); else,lastwarn(v003),end,end,if ...
v001.boolean.obj,v007=v003;while v007(end)==10,v007(end)=[];end,if any(v007==10),v007=...
char2cellstr(['Warning: ' v007]);else,v007=['Warning: ' v007];end,set(v001.obj,'String',v007),...
for v008=v001.obj(:).',try set(v008,'String',v007);catch,end,end,end,if v001.boolean.fid || ...
v001.boolean.fcn,v009=2;[v005,v004]=get_trace(v009);end,if v001.boolean.fid,for v010=...
v001.fid(:).',try fprintf(v010,'Warning: %s\n%s',v003,v005);catch,end,end,end,if ...
v001.boolean.fcn,if ismember(v000,{v004.name}),error('prevent recursion'),end,for v011=...
v001.fcn(:).',if isfield(v011,'data'),try feval(v011.h,'warning',v006,v011.data);catch,end,else,...
try feval(v011.h,'warning',v006);catch,end,end,end,end,end

##### SOURCE END #####
--></body></html>